/* tslint:disable */
/*
 * Autogenerated by @creditkarma/thrift-typescript v2.0.0
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
*/
import * as thrift from "thrift";
export enum Type {
  BOOLEAN = 0,
  INT32 = 1,
  INT64 = 2,
  INT96 = 3,
  FLOAT = 4,
  DOUBLE = 5,
  BYTE_ARRAY = 6,
  FIXED_LEN_BYTE_ARRAY = 7
}
export enum ConvertedType {
  UTF8 = 0,
  MAP = 1,
  MAP_KEY_VALUE = 2,
  LIST = 3,
  ENUM = 4,
  DECIMAL = 5,
  DATE = 6,
  TIME_MILLIS = 7,
  TIME_MICROS = 8,
  TIMESTAMP_MILLIS = 9,
  TIMESTAMP_MICROS = 10,
  UINT_8 = 11,
  UINT_16 = 12,
  UINT_32 = 13,
  UINT_64 = 14,
  INT_8 = 15,
  INT_16 = 16,
  INT_32 = 17,
  INT_64 = 18,
  JSON = 19,
  BSON = 20,
  INTERVAL = 21,
  NULL = 25
}
export enum FieldRepetitionType {
  REQUIRED = 0,
  OPTIONAL = 1,
  REPEATED = 2
}
export enum Encoding {
  PLAIN = 0,
  PLAIN_DICTIONARY = 2,
  RLE = 3,
  BIT_PACKED = 4,
  DELTA_BINARY_PACKED = 5,
  DELTA_LENGTH_BYTE_ARRAY = 6,
  DELTA_BYTE_ARRAY = 7,
  RLE_DICTIONARY = 8
}
export enum CompressionCodec {
  UNCOMPRESSED = 0,
  SNAPPY = 1,
  GZIP = 2,
  LZO = 3,
  BROTLI = 4
}
export enum PageType {
  DATA_PAGE = 0,
  INDEX_PAGE = 1,
  DICTIONARY_PAGE = 2,
  DATA_PAGE_V2 = 3
}
export interface IStatisticsArgs {
  max?: Buffer;
  min?: Buffer;
  null_count?: number | thrift.Int64;
  distinct_count?: number | thrift.Int64;
}
export class Statistics {
  public max?: Buffer;
  public min?: Buffer;
  public null_count?: thrift.Int64;
  public distinct_count?: thrift.Int64;
  constructor(args?: IStatisticsArgs) {
    if (args != null && args.max != null) {
      this.max = args.max;
    }
    if (args != null && args.min != null) {
      this.min = args.min;
    }
    if (args != null && args.null_count != null) {
      if (typeof args.null_count === "number") {
        this.null_count = new thrift.Int64(args.null_count);
      }
      else {
        this.null_count = args.null_count;
      }
    }
    if (args != null && args.distinct_count != null) {
      if (typeof args.distinct_count === "number") {
        this.distinct_count = new thrift.Int64(args.distinct_count);
      }
      else {
        this.distinct_count = args.distinct_count;
      }
    }
  }
  public write(output: thrift.TProtocol): void {
    output.writeStructBegin("Statistics");
    if (this.max != null) {
      output.writeFieldBegin("max", thrift.Thrift.Type.STRING, 1);
      output.writeBinary(this.max);
      output.writeFieldEnd();
    }
    if (this.min != null) {
      output.writeFieldBegin("min", thrift.Thrift.Type.STRING, 2);
      output.writeBinary(this.min);
      output.writeFieldEnd();
    }
    if (this.null_count != null) {
      output.writeFieldBegin("null_count", thrift.Thrift.Type.I64, 3);
      output.writeI64(this.null_count);
      output.writeFieldEnd();
    }
    if (this.distinct_count != null) {
      output.writeFieldBegin("distinct_count", thrift.Thrift.Type.I64, 4);
      output.writeI64(this.distinct_count);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
  public static read(input: thrift.TProtocol): Statistics {
    input.readStructBegin();
    let _args: any = {};
    while (true) {
      const ret: thrift.TField = input.readFieldBegin();
      const fieldType: thrift.Thrift.Type = ret.ftype;
      const fieldId: number = ret.fid;
      if (fieldType === thrift.Thrift.Type.STOP) {
        break;
      }
      switch (fieldId) {
        case 1:
          if (fieldType === thrift.Thrift.Type.STRING) {
            const value_1: Buffer = input.readBinary();
            _args.max = value_1;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 2:
          if (fieldType === thrift.Thrift.Type.STRING) {
            const value_2: Buffer = input.readBinary();
            _args.min = value_2;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 3:
          if (fieldType === thrift.Thrift.Type.I64) {
            const value_3: thrift.Int64 = input.readI64();
            _args.null_count = value_3;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 4:
          if (fieldType === thrift.Thrift.Type.I64) {
            const value_4: thrift.Int64 = input.readI64();
            _args.distinct_count = value_4;
          }
          else {
            input.skip(fieldType);
          }
          break;
        default: {
          input.skip(fieldType);
        }
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return new Statistics(_args);
  }
}
export interface ISchemaElementArgs {
  type?: Type;
  type_length?: number;
  repetition_type?: FieldRepetitionType;
  name: string;
  num_children?: number;
  converted_type?: ConvertedType;
  scale?: number;
  precision?: number;
  field_id?: number;
}
export class SchemaElement {
  public type?: Type;
  public type_length?: number;
  public repetition_type?: FieldRepetitionType;
  public name: string;
  public num_children?: number;
  public converted_type?: ConvertedType;
  public scale?: number;
  public precision?: number;
  public field_id?: number;
  constructor(args: ISchemaElementArgs) {
    if (args != null && args.type != null) {
      this.type = args.type;
    }
    if (args != null && args.type_length != null) {
      this.type_length = args.type_length;
    }
    if (args != null && args.repetition_type != null) {
      this.repetition_type = args.repetition_type;
    }
    if (args != null && args.name != null) {
      this.name = args.name;
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[name] is unset!");
    }
    if (args != null && args.num_children != null) {
      this.num_children = args.num_children;
    }
    if (args != null && args.converted_type != null) {
      this.converted_type = args.converted_type;
    }
    if (args != null && args.scale != null) {
      this.scale = args.scale;
    }
    if (args != null && args.precision != null) {
      this.precision = args.precision;
    }
    if (args != null && args.field_id != null) {
      this.field_id = args.field_id;
    }
  }
  public write(output: thrift.TProtocol): void {
    output.writeStructBegin("SchemaElement");
    if (this.type != null) {
      output.writeFieldBegin("type", thrift.Thrift.Type.I32, 1);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    if (this.type_length != null) {
      output.writeFieldBegin("type_length", thrift.Thrift.Type.I32, 2);
      output.writeI32(this.type_length);
      output.writeFieldEnd();
    }
    if (this.repetition_type != null) {
      output.writeFieldBegin("repetition_type", thrift.Thrift.Type.I32, 3);
      output.writeI32(this.repetition_type);
      output.writeFieldEnd();
    }
    if (this.name != null) {
      output.writeFieldBegin("name", thrift.Thrift.Type.STRING, 4);
      output.writeString(this.name);
      output.writeFieldEnd();
    }
    if (this.num_children != null) {
      output.writeFieldBegin("num_children", thrift.Thrift.Type.I32, 5);
      output.writeI32(this.num_children);
      output.writeFieldEnd();
    }
    if (this.converted_type != null) {
      output.writeFieldBegin("converted_type", thrift.Thrift.Type.I32, 6);
      output.writeI32(this.converted_type);
      output.writeFieldEnd();
    }
    if (this.scale != null) {
      output.writeFieldBegin("scale", thrift.Thrift.Type.I32, 7);
      output.writeI32(this.scale);
      output.writeFieldEnd();
    }
    if (this.precision != null) {
      output.writeFieldBegin("precision", thrift.Thrift.Type.I32, 8);
      output.writeI32(this.precision);
      output.writeFieldEnd();
    }
    if (this.field_id != null) {
      output.writeFieldBegin("field_id", thrift.Thrift.Type.I32, 9);
      output.writeI32(this.field_id);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
  public static read(input: thrift.TProtocol): SchemaElement {
    input.readStructBegin();
    let _args: any = {};
    while (true) {
      const ret: thrift.TField = input.readFieldBegin();
      const fieldType: thrift.Thrift.Type = ret.ftype;
      const fieldId: number = ret.fid;
      if (fieldType === thrift.Thrift.Type.STOP) {
        break;
      }
      switch (fieldId) {
        case 1:
          if (fieldType === thrift.Thrift.Type.I32) {
            const value_5: Type = input.readI32();
            _args.type = value_5;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 2:
          if (fieldType === thrift.Thrift.Type.I32) {
            const value_6: number = input.readI32();
            _args.type_length = value_6;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 3:
          if (fieldType === thrift.Thrift.Type.I32) {
            const value_7: FieldRepetitionType = input.readI32();
            _args.repetition_type = value_7;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 4:
          if (fieldType === thrift.Thrift.Type.STRING) {
            const value_8: string = input.readString();
            _args.name = value_8;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 5:
          if (fieldType === thrift.Thrift.Type.I32) {
            const value_9: number = input.readI32();
            _args.num_children = value_9;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 6:
          if (fieldType === thrift.Thrift.Type.I32) {
            const value_10: ConvertedType = input.readI32();
            _args.converted_type = value_10;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 7:
          if (fieldType === thrift.Thrift.Type.I32) {
            const value_11: number = input.readI32();
            _args.scale = value_11;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 8:
          if (fieldType === thrift.Thrift.Type.I32) {
            const value_12: number = input.readI32();
            _args.precision = value_12;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 9:
          if (fieldType === thrift.Thrift.Type.I32) {
            const value_13: number = input.readI32();
            _args.field_id = value_13;
          }
          else {
            input.skip(fieldType);
          }
          break;
        default: {
          input.skip(fieldType);
        }
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    if (_args.name !== undefined) {
      return new SchemaElement(_args);
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read SchemaElement from input");
    }
  }
}
export interface IDataPageHeaderArgs {
  num_values: number;
  encoding: Encoding;
  definition_level_encoding: Encoding;
  repetition_level_encoding: Encoding;
  statistics?: Statistics;
}
export class DataPageHeader {
  public num_values: number;
  public encoding: Encoding;
  public definition_level_encoding: Encoding;
  public repetition_level_encoding: Encoding;
  public statistics?: Statistics;
  constructor(args: IDataPageHeaderArgs) {
    if (args != null && args.num_values != null) {
      this.num_values = args.num_values;
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[num_values] is unset!");
    }
    if (args != null && args.encoding != null) {
      this.encoding = args.encoding;
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[encoding] is unset!");
    }
    if (args != null && args.definition_level_encoding != null) {
      this.definition_level_encoding = args.definition_level_encoding;
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[definition_level_encoding] is unset!");
    }
    if (args != null && args.repetition_level_encoding != null) {
      this.repetition_level_encoding = args.repetition_level_encoding;
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[repetition_level_encoding] is unset!");
    }
    if (args != null && args.statistics != null) {
      this.statistics = args.statistics;
    }
  }
  public write(output: thrift.TProtocol): void {
    output.writeStructBegin("DataPageHeader");
    if (this.num_values != null) {
      output.writeFieldBegin("num_values", thrift.Thrift.Type.I32, 1);
      output.writeI32(this.num_values);
      output.writeFieldEnd();
    }
    if (this.encoding != null) {
      output.writeFieldBegin("encoding", thrift.Thrift.Type.I32, 2);
      output.writeI32(this.encoding);
      output.writeFieldEnd();
    }
    if (this.definition_level_encoding != null) {
      output.writeFieldBegin("definition_level_encoding", thrift.Thrift.Type.I32, 3);
      output.writeI32(this.definition_level_encoding);
      output.writeFieldEnd();
    }
    if (this.repetition_level_encoding != null) {
      output.writeFieldBegin("repetition_level_encoding", thrift.Thrift.Type.I32, 4);
      output.writeI32(this.repetition_level_encoding);
      output.writeFieldEnd();
    }
    if (this.statistics != null) {
      output.writeFieldBegin("statistics", thrift.Thrift.Type.STRUCT, 5);
      this.statistics.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
  public static read(input: thrift.TProtocol): DataPageHeader {
    input.readStructBegin();
    let _args: any = {};
    while (true) {
      const ret: thrift.TField = input.readFieldBegin();
      const fieldType: thrift.Thrift.Type = ret.ftype;
      const fieldId: number = ret.fid;
      if (fieldType === thrift.Thrift.Type.STOP) {
        break;
      }
      switch (fieldId) {
        case 1:
          if (fieldType === thrift.Thrift.Type.I32) {
            const value_14: number = input.readI32();
            _args.num_values = value_14;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 2:
          if (fieldType === thrift.Thrift.Type.I32) {
            const value_15: Encoding = input.readI32();
            _args.encoding = value_15;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 3:
          if (fieldType === thrift.Thrift.Type.I32) {
            const value_16: Encoding = input.readI32();
            _args.definition_level_encoding = value_16;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 4:
          if (fieldType === thrift.Thrift.Type.I32) {
            const value_17: Encoding = input.readI32();
            _args.repetition_level_encoding = value_17;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 5:
          if (fieldType === thrift.Thrift.Type.STRUCT) {
            const value_18: Statistics = Statistics.read(input);
            _args.statistics = value_18;
          }
          else {
            input.skip(fieldType);
          }
          break;
        default: {
          input.skip(fieldType);
        }
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    if (_args.num_values !== undefined && _args.encoding !== undefined && _args.definition_level_encoding !== undefined && _args.repetition_level_encoding !== undefined) {
      return new DataPageHeader(_args);
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read DataPageHeader from input");
    }
  }
}
export interface IIndexPageHeaderArgs {
}
export class IndexPageHeader {
  constructor() {
  }
  public write(output: thrift.TProtocol): void {
    output.writeStructBegin("IndexPageHeader");
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
  public static read(input: thrift.TProtocol): IndexPageHeader {
    input.readStructBegin();
    while (true) {
      const ret: thrift.TField = input.readFieldBegin();
      const fieldType: thrift.Thrift.Type = ret.ftype;
      const fieldId: number = ret.fid;
      if (fieldType === thrift.Thrift.Type.STOP) {
        break;
      }
      switch (fieldId) {
        default: {
          input.skip(fieldType);
        }
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return new IndexPageHeader();
  }
}
export interface IDictionaryPageHeaderArgs {
  num_values: number;
  encoding: Encoding;
  is_sorted?: boolean;
}
export class DictionaryPageHeader {
  public num_values: number;
  public encoding: Encoding;
  public is_sorted?: boolean;
  constructor(args: IDictionaryPageHeaderArgs) {
    if (args != null && args.num_values != null) {
      this.num_values = args.num_values;
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[num_values] is unset!");
    }
    if (args != null && args.encoding != null) {
      this.encoding = args.encoding;
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[encoding] is unset!");
    }
    if (args != null && args.is_sorted != null) {
      this.is_sorted = args.is_sorted;
    }
  }
  public write(output: thrift.TProtocol): void {
    output.writeStructBegin("DictionaryPageHeader");
    if (this.num_values != null) {
      output.writeFieldBegin("num_values", thrift.Thrift.Type.I32, 1);
      output.writeI32(this.num_values);
      output.writeFieldEnd();
    }
    if (this.encoding != null) {
      output.writeFieldBegin("encoding", thrift.Thrift.Type.I32, 2);
      output.writeI32(this.encoding);
      output.writeFieldEnd();
    }
    if (this.is_sorted != null) {
      output.writeFieldBegin("is_sorted", thrift.Thrift.Type.BOOL, 3);
      output.writeBool(this.is_sorted);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
  public static read(input: thrift.TProtocol): DictionaryPageHeader {
    input.readStructBegin();
    let _args: any = {};
    while (true) {
      const ret: thrift.TField = input.readFieldBegin();
      const fieldType: thrift.Thrift.Type = ret.ftype;
      const fieldId: number = ret.fid;
      if (fieldType === thrift.Thrift.Type.STOP) {
        break;
      }
      switch (fieldId) {
        case 1:
          if (fieldType === thrift.Thrift.Type.I32) {
            const value_19: number = input.readI32();
            _args.num_values = value_19;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 2:
          if (fieldType === thrift.Thrift.Type.I32) {
            const value_20: Encoding = input.readI32();
            _args.encoding = value_20;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 3:
          if (fieldType === thrift.Thrift.Type.BOOL) {
            const value_21: boolean = input.readBool();
            _args.is_sorted = value_21;
          }
          else {
            input.skip(fieldType);
          }
          break;
        default: {
          input.skip(fieldType);
        }
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    if (_args.num_values !== undefined && _args.encoding !== undefined) {
      return new DictionaryPageHeader(_args);
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read DictionaryPageHeader from input");
    }
  }
}
export interface IDataPageHeaderV2Args {
  num_values: number;
  num_nulls: number;
  num_rows: number;
  encoding: Encoding;
  definition_levels_byte_length: number;
  repetition_levels_byte_length: number;
  is_compressed?: boolean;
  statistics?: Statistics;
}
export class DataPageHeaderV2 {
  public num_values: number;
  public num_nulls: number;
  public num_rows: number;
  public encoding: Encoding;
  public definition_levels_byte_length: number;
  public repetition_levels_byte_length: number;
  public is_compressed?: boolean = true;
  public statistics?: Statistics;
  constructor(args: IDataPageHeaderV2Args) {
    if (args != null && args.num_values != null) {
      this.num_values = args.num_values;
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[num_values] is unset!");
    }
    if (args != null && args.num_nulls != null) {
      this.num_nulls = args.num_nulls;
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[num_nulls] is unset!");
    }
    if (args != null && args.num_rows != null) {
      this.num_rows = args.num_rows;
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[num_rows] is unset!");
    }
    if (args != null && args.encoding != null) {
      this.encoding = args.encoding;
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[encoding] is unset!");
    }
    if (args != null && args.definition_levels_byte_length != null) {
      this.definition_levels_byte_length = args.definition_levels_byte_length;
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[definition_levels_byte_length] is unset!");
    }
    if (args != null && args.repetition_levels_byte_length != null) {
      this.repetition_levels_byte_length = args.repetition_levels_byte_length;
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[repetition_levels_byte_length] is unset!");
    }
    if (args != null && args.is_compressed != null) {
      this.is_compressed = args.is_compressed;
    }
    if (args != null && args.statistics != null) {
      this.statistics = args.statistics;
    }
  }
  public write(output: thrift.TProtocol): void {
    output.writeStructBegin("DataPageHeaderV2");
    if (this.num_values != null) {
      output.writeFieldBegin("num_values", thrift.Thrift.Type.I32, 1);
      output.writeI32(this.num_values);
      output.writeFieldEnd();
    }
    if (this.num_nulls != null) {
      output.writeFieldBegin("num_nulls", thrift.Thrift.Type.I32, 2);
      output.writeI32(this.num_nulls);
      output.writeFieldEnd();
    }
    if (this.num_rows != null) {
      output.writeFieldBegin("num_rows", thrift.Thrift.Type.I32, 3);
      output.writeI32(this.num_rows);
      output.writeFieldEnd();
    }
    if (this.encoding != null) {
      output.writeFieldBegin("encoding", thrift.Thrift.Type.I32, 4);
      output.writeI32(this.encoding);
      output.writeFieldEnd();
    }
    if (this.definition_levels_byte_length != null) {
      output.writeFieldBegin("definition_levels_byte_length", thrift.Thrift.Type.I32, 5);
      output.writeI32(this.definition_levels_byte_length);
      output.writeFieldEnd();
    }
    if (this.repetition_levels_byte_length != null) {
      output.writeFieldBegin("repetition_levels_byte_length", thrift.Thrift.Type.I32, 6);
      output.writeI32(this.repetition_levels_byte_length);
      output.writeFieldEnd();
    }
    if (this.is_compressed != null) {
      output.writeFieldBegin("is_compressed", thrift.Thrift.Type.BOOL, 7);
      output.writeBool(this.is_compressed);
      output.writeFieldEnd();
    }
    if (this.statistics != null) {
      output.writeFieldBegin("statistics", thrift.Thrift.Type.STRUCT, 8);
      this.statistics.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
  public static read(input: thrift.TProtocol): DataPageHeaderV2 {
    input.readStructBegin();
    let _args: any = {};
    while (true) {
      const ret: thrift.TField = input.readFieldBegin();
      const fieldType: thrift.Thrift.Type = ret.ftype;
      const fieldId: number = ret.fid;
      if (fieldType === thrift.Thrift.Type.STOP) {
        break;
      }
      switch (fieldId) {
        case 1:
          if (fieldType === thrift.Thrift.Type.I32) {
            const value_22: number = input.readI32();
            _args.num_values = value_22;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 2:
          if (fieldType === thrift.Thrift.Type.I32) {
            const value_23: number = input.readI32();
            _args.num_nulls = value_23;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 3:
          if (fieldType === thrift.Thrift.Type.I32) {
            const value_24: number = input.readI32();
            _args.num_rows = value_24;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 4:
          if (fieldType === thrift.Thrift.Type.I32) {
            const value_25: Encoding = input.readI32();
            _args.encoding = value_25;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 5:
          if (fieldType === thrift.Thrift.Type.I32) {
            const value_26: number = input.readI32();
            _args.definition_levels_byte_length = value_26;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 6:
          if (fieldType === thrift.Thrift.Type.I32) {
            const value_27: number = input.readI32();
            _args.repetition_levels_byte_length = value_27;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 7:
          if (fieldType === thrift.Thrift.Type.BOOL) {
            const value_28: boolean = input.readBool();
            _args.is_compressed = value_28;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 8:
          if (fieldType === thrift.Thrift.Type.STRUCT) {
            const value_29: Statistics = Statistics.read(input);
            _args.statistics = value_29;
          }
          else {
            input.skip(fieldType);
          }
          break;
        default: {
          input.skip(fieldType);
        }
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    if (_args.num_values !== undefined && _args.num_nulls !== undefined && _args.num_rows !== undefined && _args.encoding !== undefined && _args.definition_levels_byte_length !== undefined && _args.repetition_levels_byte_length !== undefined) {
      return new DataPageHeaderV2(_args);
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read DataPageHeaderV2 from input");
    }
  }
}
export interface IPageHeaderArgs {
  type: PageType;
  uncompressed_page_size: number;
  compressed_page_size: number;
  crc?: number;
  data_page_header?: DataPageHeader;
  index_page_header?: IndexPageHeader;
  dictionary_page_header?: DictionaryPageHeader;
  data_page_header_v2?: DataPageHeaderV2;
}
export class PageHeader {
  public type: PageType;
  public uncompressed_page_size: number;
  public compressed_page_size: number;
  public crc?: number;
  public data_page_header?: DataPageHeader;
  public index_page_header?: IndexPageHeader;
  public dictionary_page_header?: DictionaryPageHeader;
  public data_page_header_v2?: DataPageHeaderV2;
  constructor(args: IPageHeaderArgs) {
    if (args != null && args.type != null) {
      this.type = args.type;
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[type] is unset!");
    }
    if (args != null && args.uncompressed_page_size != null) {
      this.uncompressed_page_size = args.uncompressed_page_size;
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[uncompressed_page_size] is unset!");
    }
    if (args != null && args.compressed_page_size != null) {
      this.compressed_page_size = args.compressed_page_size;
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[compressed_page_size] is unset!");
    }
    if (args != null && args.crc != null) {
      this.crc = args.crc;
    }
    if (args != null && args.data_page_header != null) {
      this.data_page_header = args.data_page_header;
    }
    if (args != null && args.index_page_header != null) {
      this.index_page_header = args.index_page_header;
    }
    if (args != null && args.dictionary_page_header != null) {
      this.dictionary_page_header = args.dictionary_page_header;
    }
    if (args != null && args.data_page_header_v2 != null) {
      this.data_page_header_v2 = args.data_page_header_v2;
    }
  }
  public write(output: thrift.TProtocol): void {
    output.writeStructBegin("PageHeader");
    if (this.type != null) {
      output.writeFieldBegin("type", thrift.Thrift.Type.I32, 1);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    if (this.uncompressed_page_size != null) {
      output.writeFieldBegin("uncompressed_page_size", thrift.Thrift.Type.I32, 2);
      output.writeI32(this.uncompressed_page_size);
      output.writeFieldEnd();
    }
    if (this.compressed_page_size != null) {
      output.writeFieldBegin("compressed_page_size", thrift.Thrift.Type.I32, 3);
      output.writeI32(this.compressed_page_size);
      output.writeFieldEnd();
    }
    if (this.crc != null) {
      output.writeFieldBegin("crc", thrift.Thrift.Type.I32, 4);
      output.writeI32(this.crc);
      output.writeFieldEnd();
    }
    if (this.data_page_header != null) {
      output.writeFieldBegin("data_page_header", thrift.Thrift.Type.STRUCT, 5);
      this.data_page_header.write(output);
      output.writeFieldEnd();
    }
    if (this.index_page_header != null) {
      output.writeFieldBegin("index_page_header", thrift.Thrift.Type.STRUCT, 6);
      this.index_page_header.write(output);
      output.writeFieldEnd();
    }
    if (this.dictionary_page_header != null) {
      output.writeFieldBegin("dictionary_page_header", thrift.Thrift.Type.STRUCT, 7);
      this.dictionary_page_header.write(output);
      output.writeFieldEnd();
    }
    if (this.data_page_header_v2 != null) {
      output.writeFieldBegin("data_page_header_v2", thrift.Thrift.Type.STRUCT, 8);
      this.data_page_header_v2.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
  public static read(input: thrift.TProtocol): PageHeader {
    input.readStructBegin();
    let _args: any = {};
    while (true) {
      const ret: thrift.TField = input.readFieldBegin();
      const fieldType: thrift.Thrift.Type = ret.ftype;
      const fieldId: number = ret.fid;
      if (fieldType === thrift.Thrift.Type.STOP) {
        break;
      }
      switch (fieldId) {
        case 1:
          if (fieldType === thrift.Thrift.Type.I32) {
            const value_30: PageType = input.readI32();
            _args.type = value_30;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 2:
          if (fieldType === thrift.Thrift.Type.I32) {
            const value_31: number = input.readI32();
            _args.uncompressed_page_size = value_31;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 3:
          if (fieldType === thrift.Thrift.Type.I32) {
            const value_32: number = input.readI32();
            _args.compressed_page_size = value_32;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 4:
          if (fieldType === thrift.Thrift.Type.I32) {
            const value_33: number = input.readI32();
            _args.crc = value_33;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 5:
          if (fieldType === thrift.Thrift.Type.STRUCT) {
            const value_34: DataPageHeader = DataPageHeader.read(input);
            _args.data_page_header = value_34;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 6:
          if (fieldType === thrift.Thrift.Type.STRUCT) {
            const value_35: IndexPageHeader = IndexPageHeader.read(input);
            _args.index_page_header = value_35;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 7:
          if (fieldType === thrift.Thrift.Type.STRUCT) {
            const value_36: DictionaryPageHeader = DictionaryPageHeader.read(input);
            _args.dictionary_page_header = value_36;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 8:
          if (fieldType === thrift.Thrift.Type.STRUCT) {
            const value_37: DataPageHeaderV2 = DataPageHeaderV2.read(input);
            _args.data_page_header_v2 = value_37;
          }
          else {
            input.skip(fieldType);
          }
          break;
        default: {
          input.skip(fieldType);
        }
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    if (_args.type !== undefined && _args.uncompressed_page_size !== undefined && _args.compressed_page_size !== undefined) {
      return new PageHeader(_args);
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read PageHeader from input");
    }
  }
}
export interface IKeyValueArgs {
  key: string;
  value?: string;
}
export class KeyValue {
  public key: string;
  public value?: string;
  constructor(args: IKeyValueArgs) {
    if (args != null && args.key != null) {
      this.key = args.key;
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[key] is unset!");
    }
    if (args != null && args.value != null) {
      this.value = args.value;
    }
  }
  public write(output: thrift.TProtocol): void {
    output.writeStructBegin("KeyValue");
    if (this.key != null) {
      output.writeFieldBegin("key", thrift.Thrift.Type.STRING, 1);
      output.writeString(this.key);
      output.writeFieldEnd();
    }
    if (this.value != null) {
      output.writeFieldBegin("value", thrift.Thrift.Type.STRING, 2);
      output.writeString(this.value);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
  public static read(input: thrift.TProtocol): KeyValue {
    input.readStructBegin();
    let _args: any = {};
    while (true) {
      const ret: thrift.TField = input.readFieldBegin();
      const fieldType: thrift.Thrift.Type = ret.ftype;
      const fieldId: number = ret.fid;
      if (fieldType === thrift.Thrift.Type.STOP) {
        break;
      }
      switch (fieldId) {
        case 1:
          if (fieldType === thrift.Thrift.Type.STRING) {
            const value_38: string = input.readString();
            _args.key = value_38;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 2:
          if (fieldType === thrift.Thrift.Type.STRING) {
            const value_39: string = input.readString();
            _args.value = value_39;
          }
          else {
            input.skip(fieldType);
          }
          break;
        default: {
          input.skip(fieldType);
        }
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    if (_args.key !== undefined) {
      return new KeyValue(_args);
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read KeyValue from input");
    }
  }
}
export interface ISortingColumnArgs {
  column_idx: number;
  descending: boolean;
  nulls_first: boolean;
}
export class SortingColumn {
  public column_idx: number;
  public descending: boolean;
  public nulls_first: boolean;
  constructor(args: ISortingColumnArgs) {
    if (args != null && args.column_idx != null) {
      this.column_idx = args.column_idx;
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[column_idx] is unset!");
    }
    if (args != null && args.descending != null) {
      this.descending = args.descending;
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[descending] is unset!");
    }
    if (args != null && args.nulls_first != null) {
      this.nulls_first = args.nulls_first;
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[nulls_first] is unset!");
    }
  }
  public write(output: thrift.TProtocol): void {
    output.writeStructBegin("SortingColumn");
    if (this.column_idx != null) {
      output.writeFieldBegin("column_idx", thrift.Thrift.Type.I32, 1);
      output.writeI32(this.column_idx);
      output.writeFieldEnd();
    }
    if (this.descending != null) {
      output.writeFieldBegin("descending", thrift.Thrift.Type.BOOL, 2);
      output.writeBool(this.descending);
      output.writeFieldEnd();
    }
    if (this.nulls_first != null) {
      output.writeFieldBegin("nulls_first", thrift.Thrift.Type.BOOL, 3);
      output.writeBool(this.nulls_first);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
  public static read(input: thrift.TProtocol): SortingColumn {
    input.readStructBegin();
    let _args: any = {};
    while (true) {
      const ret: thrift.TField = input.readFieldBegin();
      const fieldType: thrift.Thrift.Type = ret.ftype;
      const fieldId: number = ret.fid;
      if (fieldType === thrift.Thrift.Type.STOP) {
        break;
      }
      switch (fieldId) {
        case 1:
          if (fieldType === thrift.Thrift.Type.I32) {
            const value_40: number = input.readI32();
            _args.column_idx = value_40;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 2:
          if (fieldType === thrift.Thrift.Type.BOOL) {
            const value_41: boolean = input.readBool();
            _args.descending = value_41;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 3:
          if (fieldType === thrift.Thrift.Type.BOOL) {
            const value_42: boolean = input.readBool();
            _args.nulls_first = value_42;
          }
          else {
            input.skip(fieldType);
          }
          break;
        default: {
          input.skip(fieldType);
        }
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    if (_args.column_idx !== undefined && _args.descending !== undefined && _args.nulls_first !== undefined) {
      return new SortingColumn(_args);
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read SortingColumn from input");
    }
  }
}
export interface IPageEncodingStatsArgs {
  page_type: PageType;
  encoding: Encoding;
  count: number;
}
export class PageEncodingStats {
  public page_type: PageType;
  public encoding: Encoding;
  public count: number;
  constructor(args: IPageEncodingStatsArgs) {
    if (args != null && args.page_type != null) {
      this.page_type = args.page_type;
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[page_type] is unset!");
    }
    if (args != null && args.encoding != null) {
      this.encoding = args.encoding;
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[encoding] is unset!");
    }
    if (args != null && args.count != null) {
      this.count = args.count;
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[count] is unset!");
    }
  }
  public write(output: thrift.TProtocol): void {
    output.writeStructBegin("PageEncodingStats");
    if (this.page_type != null) {
      output.writeFieldBegin("page_type", thrift.Thrift.Type.I32, 1);
      output.writeI32(this.page_type);
      output.writeFieldEnd();
    }
    if (this.encoding != null) {
      output.writeFieldBegin("encoding", thrift.Thrift.Type.I32, 2);
      output.writeI32(this.encoding);
      output.writeFieldEnd();
    }
    if (this.count != null) {
      output.writeFieldBegin("count", thrift.Thrift.Type.I32, 3);
      output.writeI32(this.count);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
  public static read(input: thrift.TProtocol): PageEncodingStats {
    input.readStructBegin();
    let _args: any = {};
    while (true) {
      const ret: thrift.TField = input.readFieldBegin();
      const fieldType: thrift.Thrift.Type = ret.ftype;
      const fieldId: number = ret.fid;
      if (fieldType === thrift.Thrift.Type.STOP) {
        break;
      }
      switch (fieldId) {
        case 1:
          if (fieldType === thrift.Thrift.Type.I32) {
            const value_43: PageType = input.readI32();
            _args.page_type = value_43;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 2:
          if (fieldType === thrift.Thrift.Type.I32) {
            const value_44: Encoding = input.readI32();
            _args.encoding = value_44;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 3:
          if (fieldType === thrift.Thrift.Type.I32) {
            const value_45: number = input.readI32();
            _args.count = value_45;
          }
          else {
            input.skip(fieldType);
          }
          break;
        default: {
          input.skip(fieldType);
        }
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    if (_args.page_type !== undefined && _args.encoding !== undefined && _args.count !== undefined) {
      return new PageEncodingStats(_args);
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read PageEncodingStats from input");
    }
  }
}
export interface IColumnMetaDataArgs {
  type: Type;
  encodings: Array<Encoding>;
  path_in_schema: Array<string>;
  codec: CompressionCodec;
  num_values: number | thrift.Int64;
  total_uncompressed_size: number | thrift.Int64;
  total_compressed_size: number | thrift.Int64;
  key_value_metadata?: Array<KeyValue>;
  data_page_offset: number | thrift.Int64;
  index_page_offset?: number | thrift.Int64;
  dictionary_page_offset?: number | thrift.Int64;
  statistics?: Statistics;
  encoding_stats?: Array<PageEncodingStats>;
}
export class ColumnMetaData {
  public type: Type;
  public encodings: Array<Encoding>;
  public path_in_schema: Array<string>;
  public codec: CompressionCodec;
  public num_values: thrift.Int64;
  public total_uncompressed_size: thrift.Int64;
  public total_compressed_size: thrift.Int64;
  public key_value_metadata?: Array<KeyValue>;
  public data_page_offset: thrift.Int64;
  public index_page_offset?: thrift.Int64;
  public dictionary_page_offset?: thrift.Int64;
  public statistics?: Statistics;
  public encoding_stats?: Array<PageEncodingStats>;
  constructor(args: IColumnMetaDataArgs) {
    if (args != null && args.type != null) {
      this.type = args.type;
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[type] is unset!");
    }
    if (args != null && args.encodings != null) {
      this.encodings = args.encodings;
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[encodings] is unset!");
    }
    if (args != null && args.path_in_schema != null) {
      this.path_in_schema = args.path_in_schema;
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[path_in_schema] is unset!");
    }
    if (args != null && args.codec != null) {
      this.codec = args.codec;
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[codec] is unset!");
    }
    if (args != null && args.num_values != null) {
      if (typeof args.num_values === "number") {
        this.num_values = new thrift.Int64(args.num_values);
      }
      else {
        this.num_values = args.num_values;
      }
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[num_values] is unset!");
    }
    if (args != null && args.total_uncompressed_size != null) {
      if (typeof args.total_uncompressed_size === "number") {
        this.total_uncompressed_size = new thrift.Int64(args.total_uncompressed_size);
      }
      else {
        this.total_uncompressed_size = args.total_uncompressed_size;
      }
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[total_uncompressed_size] is unset!");
    }
    if (args != null && args.total_compressed_size != null) {
      if (typeof args.total_compressed_size === "number") {
        this.total_compressed_size = new thrift.Int64(args.total_compressed_size);
      }
      else {
        this.total_compressed_size = args.total_compressed_size;
      }
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[total_compressed_size] is unset!");
    }
    if (args != null && args.key_value_metadata != null) {
      this.key_value_metadata = args.key_value_metadata;
    }
    if (args != null && args.data_page_offset != null) {
      if (typeof args.data_page_offset === "number") {
        this.data_page_offset = new thrift.Int64(args.data_page_offset);
      }
      else {
        this.data_page_offset = args.data_page_offset;
      }
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[data_page_offset] is unset!");
    }
    if (args != null && args.index_page_offset != null) {
      if (typeof args.index_page_offset === "number") {
        this.index_page_offset = new thrift.Int64(args.index_page_offset);
      }
      else {
        this.index_page_offset = args.index_page_offset;
      }
    }
    if (args != null && args.dictionary_page_offset != null) {
      if (typeof args.dictionary_page_offset === "number") {
        this.dictionary_page_offset = new thrift.Int64(args.dictionary_page_offset);
      }
      else {
        this.dictionary_page_offset = args.dictionary_page_offset;
      }
    }
    if (args != null && args.statistics != null) {
      this.statistics = args.statistics;
    }
    if (args != null && args.encoding_stats != null) {
      this.encoding_stats = args.encoding_stats;
    }
  }
  public write(output: thrift.TProtocol): void {
    output.writeStructBegin("ColumnMetaData");
    if (this.type != null) {
      output.writeFieldBegin("type", thrift.Thrift.Type.I32, 1);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    if (this.encodings != null) {
      output.writeFieldBegin("encodings", thrift.Thrift.Type.LIST, 2);
      output.writeListBegin(thrift.Thrift.Type.I32, this.encodings.length);
      this.encodings.forEach((value_46: Encoding): void => {
        output.writeI32(value_46);
      });
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.path_in_schema != null) {
      output.writeFieldBegin("path_in_schema", thrift.Thrift.Type.LIST, 3);
      output.writeListBegin(thrift.Thrift.Type.STRING, this.path_in_schema.length);
      this.path_in_schema.forEach((value_47: string): void => {
        output.writeString(value_47);
      });
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.codec != null) {
      output.writeFieldBegin("codec", thrift.Thrift.Type.I32, 4);
      output.writeI32(this.codec);
      output.writeFieldEnd();
    }
    if (this.num_values != null) {
      output.writeFieldBegin("num_values", thrift.Thrift.Type.I64, 5);
      output.writeI64(this.num_values);
      output.writeFieldEnd();
    }
    if (this.total_uncompressed_size != null) {
      output.writeFieldBegin("total_uncompressed_size", thrift.Thrift.Type.I64, 6);
      output.writeI64(this.total_uncompressed_size);
      output.writeFieldEnd();
    }
    if (this.total_compressed_size != null) {
      output.writeFieldBegin("total_compressed_size", thrift.Thrift.Type.I64, 7);
      output.writeI64(this.total_compressed_size);
      output.writeFieldEnd();
    }
    if (this.key_value_metadata != null) {
      output.writeFieldBegin("key_value_metadata", thrift.Thrift.Type.LIST, 8);
      output.writeListBegin(thrift.Thrift.Type.STRUCT, this.key_value_metadata.length);
      this.key_value_metadata.forEach((value_48: KeyValue): void => {
        value_48.write(output);
      });
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.data_page_offset != null) {
      output.writeFieldBegin("data_page_offset", thrift.Thrift.Type.I64, 9);
      output.writeI64(this.data_page_offset);
      output.writeFieldEnd();
    }
    if (this.index_page_offset != null) {
      output.writeFieldBegin("index_page_offset", thrift.Thrift.Type.I64, 10);
      output.writeI64(this.index_page_offset);
      output.writeFieldEnd();
    }
    if (this.dictionary_page_offset != null) {
      output.writeFieldBegin("dictionary_page_offset", thrift.Thrift.Type.I64, 11);
      output.writeI64(this.dictionary_page_offset);
      output.writeFieldEnd();
    }
    if (this.statistics != null) {
      output.writeFieldBegin("statistics", thrift.Thrift.Type.STRUCT, 12);
      this.statistics.write(output);
      output.writeFieldEnd();
    }
    if (this.encoding_stats != null) {
      output.writeFieldBegin("encoding_stats", thrift.Thrift.Type.LIST, 13);
      output.writeListBegin(thrift.Thrift.Type.STRUCT, this.encoding_stats.length);
      this.encoding_stats.forEach((value_49: PageEncodingStats): void => {
        value_49.write(output);
      });
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
  public static read(input: thrift.TProtocol): ColumnMetaData {
    input.readStructBegin();
    let _args: any = {};
    while (true) {
      const ret: thrift.TField = input.readFieldBegin();
      const fieldType: thrift.Thrift.Type = ret.ftype;
      const fieldId: number = ret.fid;
      if (fieldType === thrift.Thrift.Type.STOP) {
        break;
      }
      switch (fieldId) {
        case 1:
          if (fieldType === thrift.Thrift.Type.I32) {
            const value_50: Type = input.readI32();
            _args.type = value_50;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 2:
          if (fieldType === thrift.Thrift.Type.LIST) {
            const value_51: Array<Encoding> = new Array<Encoding>();
            const metadata_1: thrift.TList = input.readListBegin();
            const size_1: number = metadata_1.size;
            for (let i_1: number = 0; i_1 < size_1; i_1++) {
              const value_52: Encoding = input.readI32();
              value_51.push(value_52);
            }
            input.readListEnd();
            _args.encodings = value_51;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 3:
          if (fieldType === thrift.Thrift.Type.LIST) {
            const value_53: Array<string> = new Array<string>();
            const metadata_2: thrift.TList = input.readListBegin();
            const size_2: number = metadata_2.size;
            for (let i_2: number = 0; i_2 < size_2; i_2++) {
              const value_54: string = input.readString();
              value_53.push(value_54);
            }
            input.readListEnd();
            _args.path_in_schema = value_53;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 4:
          if (fieldType === thrift.Thrift.Type.I32) {
            const value_55: CompressionCodec = input.readI32();
            _args.codec = value_55;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 5:
          if (fieldType === thrift.Thrift.Type.I64) {
            const value_56: thrift.Int64 = input.readI64();
            _args.num_values = value_56;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 6:
          if (fieldType === thrift.Thrift.Type.I64) {
            const value_57: thrift.Int64 = input.readI64();
            _args.total_uncompressed_size = value_57;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 7:
          if (fieldType === thrift.Thrift.Type.I64) {
            const value_58: thrift.Int64 = input.readI64();
            _args.total_compressed_size = value_58;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 8:
          if (fieldType === thrift.Thrift.Type.LIST) {
            const value_59: Array<KeyValue> = new Array<KeyValue>();
            const metadata_3: thrift.TList = input.readListBegin();
            const size_3: number = metadata_3.size;
            for (let i_3: number = 0; i_3 < size_3; i_3++) {
              const value_60: KeyValue = KeyValue.read(input);
              value_59.push(value_60);
            }
            input.readListEnd();
            _args.key_value_metadata = value_59;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 9:
          if (fieldType === thrift.Thrift.Type.I64) {
            const value_61: thrift.Int64 = input.readI64();
            _args.data_page_offset = value_61;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 10:
          if (fieldType === thrift.Thrift.Type.I64) {
            const value_62: thrift.Int64 = input.readI64();
            _args.index_page_offset = value_62;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 11:
          if (fieldType === thrift.Thrift.Type.I64) {
            const value_63: thrift.Int64 = input.readI64();
            _args.dictionary_page_offset = value_63;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 12:
          if (fieldType === thrift.Thrift.Type.STRUCT) {
            const value_64: Statistics = Statistics.read(input);
            _args.statistics = value_64;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 13:
          if (fieldType === thrift.Thrift.Type.LIST) {
            const value_65: Array<PageEncodingStats> = new Array<PageEncodingStats>();
            const metadata_4: thrift.TList = input.readListBegin();
            const size_4: number = metadata_4.size;
            for (let i_4: number = 0; i_4 < size_4; i_4++) {
              const value_66: PageEncodingStats = PageEncodingStats.read(input);
              value_65.push(value_66);
            }
            input.readListEnd();
            _args.encoding_stats = value_65;
          }
          else {
            input.skip(fieldType);
          }
          break;
        default: {
          input.skip(fieldType);
        }
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    if (_args.type !== undefined && _args.encodings !== undefined && _args.path_in_schema !== undefined && _args.codec !== undefined && _args.num_values !== undefined && _args.total_uncompressed_size !== undefined && _args.total_compressed_size !== undefined && _args.data_page_offset !== undefined) {
      return new ColumnMetaData(_args);
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ColumnMetaData from input");
    }
  }
}
export interface IColumnChunkArgs {
  file_path?: string;
  file_offset: number | thrift.Int64;
  meta_data?: ColumnMetaData;
}
export class ColumnChunk {
  public file_path?: string;
  public file_offset: thrift.Int64;
  public meta_data?: ColumnMetaData;
  constructor(args: IColumnChunkArgs) {
    if (args != null && args.file_path != null) {
      this.file_path = args.file_path;
    }
    if (args != null && args.file_offset != null) {
      if (typeof args.file_offset === "number") {
        this.file_offset = new thrift.Int64(args.file_offset);
      }
      else {
        this.file_offset = args.file_offset;
      }
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[file_offset] is unset!");
    }
    if (args != null && args.meta_data != null) {
      this.meta_data = args.meta_data;
    }
  }
  public write(output: thrift.TProtocol): void {
    output.writeStructBegin("ColumnChunk");
    if (this.file_path != null) {
      output.writeFieldBegin("file_path", thrift.Thrift.Type.STRING, 1);
      output.writeString(this.file_path);
      output.writeFieldEnd();
    }
    if (this.file_offset != null) {
      output.writeFieldBegin("file_offset", thrift.Thrift.Type.I64, 2);
      output.writeI64(this.file_offset);
      output.writeFieldEnd();
    }
    if (this.meta_data != null) {
      output.writeFieldBegin("meta_data", thrift.Thrift.Type.STRUCT, 3);
      this.meta_data.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
  public static read(input: thrift.TProtocol): ColumnChunk {
    input.readStructBegin();
    let _args: any = {};
    while (true) {
      const ret: thrift.TField = input.readFieldBegin();
      const fieldType: thrift.Thrift.Type = ret.ftype;
      const fieldId: number = ret.fid;
      if (fieldType === thrift.Thrift.Type.STOP) {
        break;
      }
      switch (fieldId) {
        case 1:
          if (fieldType === thrift.Thrift.Type.STRING) {
            const value_67: string = input.readString();
            _args.file_path = value_67;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 2:
          if (fieldType === thrift.Thrift.Type.I64) {
            const value_68: thrift.Int64 = input.readI64();
            _args.file_offset = value_68;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 3:
          if (fieldType === thrift.Thrift.Type.STRUCT) {
            const value_69: ColumnMetaData = ColumnMetaData.read(input);
            _args.meta_data = value_69;
          }
          else {
            input.skip(fieldType);
          }
          break;
        default: {
          input.skip(fieldType);
        }
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    if (_args.file_offset !== undefined) {
      return new ColumnChunk(_args);
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ColumnChunk from input");
    }
  }
}
export interface IRowGroupArgs {
  columns: Array<ColumnChunk>;
  total_byte_size: number | thrift.Int64;
  num_rows: number | thrift.Int64;
  sorting_columns?: Array<SortingColumn>;
}
export class RowGroup {
  public columns: Array<ColumnChunk>;
  public total_byte_size: thrift.Int64;
  public num_rows: thrift.Int64;
  public sorting_columns?: Array<SortingColumn>;
  constructor(args: IRowGroupArgs) {
    if (args != null && args.columns != null) {
      this.columns = args.columns;
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[columns] is unset!");
    }
    if (args != null && args.total_byte_size != null) {
      if (typeof args.total_byte_size === "number") {
        this.total_byte_size = new thrift.Int64(args.total_byte_size);
      }
      else {
        this.total_byte_size = args.total_byte_size;
      }
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[total_byte_size] is unset!");
    }
    if (args != null && args.num_rows != null) {
      if (typeof args.num_rows === "number") {
        this.num_rows = new thrift.Int64(args.num_rows);
      }
      else {
        this.num_rows = args.num_rows;
      }
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[num_rows] is unset!");
    }
    if (args != null && args.sorting_columns != null) {
      this.sorting_columns = args.sorting_columns;
    }
  }
  public write(output: thrift.TProtocol): void {
    output.writeStructBegin("RowGroup");
    if (this.columns != null) {
      output.writeFieldBegin("columns", thrift.Thrift.Type.LIST, 1);
      output.writeListBegin(thrift.Thrift.Type.STRUCT, this.columns.length);
      this.columns.forEach((value_70: ColumnChunk): void => {
        value_70.write(output);
      });
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.total_byte_size != null) {
      output.writeFieldBegin("total_byte_size", thrift.Thrift.Type.I64, 2);
      output.writeI64(this.total_byte_size);
      output.writeFieldEnd();
    }
    if (this.num_rows != null) {
      output.writeFieldBegin("num_rows", thrift.Thrift.Type.I64, 3);
      output.writeI64(this.num_rows);
      output.writeFieldEnd();
    }
    if (this.sorting_columns != null) {
      output.writeFieldBegin("sorting_columns", thrift.Thrift.Type.LIST, 4);
      output.writeListBegin(thrift.Thrift.Type.STRUCT, this.sorting_columns.length);
      this.sorting_columns.forEach((value_71: SortingColumn): void => {
        value_71.write(output);
      });
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
  public static read(input: thrift.TProtocol): RowGroup {
    input.readStructBegin();
    let _args: any = {};
    while (true) {
      const ret: thrift.TField = input.readFieldBegin();
      const fieldType: thrift.Thrift.Type = ret.ftype;
      const fieldId: number = ret.fid;
      if (fieldType === thrift.Thrift.Type.STOP) {
        break;
      }
      switch (fieldId) {
        case 1:
          if (fieldType === thrift.Thrift.Type.LIST) {
            const value_72: Array<ColumnChunk> = new Array<ColumnChunk>();
            const metadata_5: thrift.TList = input.readListBegin();
            const size_5: number = metadata_5.size;
            for (let i_5: number = 0; i_5 < size_5; i_5++) {
              const value_73: ColumnChunk = ColumnChunk.read(input);
              value_72.push(value_73);
            }
            input.readListEnd();
            _args.columns = value_72;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 2:
          if (fieldType === thrift.Thrift.Type.I64) {
            const value_74: thrift.Int64 = input.readI64();
            _args.total_byte_size = value_74;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 3:
          if (fieldType === thrift.Thrift.Type.I64) {
            const value_75: thrift.Int64 = input.readI64();
            _args.num_rows = value_75;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 4:
          if (fieldType === thrift.Thrift.Type.LIST) {
            const value_76: Array<SortingColumn> = new Array<SortingColumn>();
            const metadata_6: thrift.TList = input.readListBegin();
            const size_6: number = metadata_6.size;
            for (let i_6: number = 0; i_6 < size_6; i_6++) {
              const value_77: SortingColumn = SortingColumn.read(input);
              value_76.push(value_77);
            }
            input.readListEnd();
            _args.sorting_columns = value_76;
          }
          else {
            input.skip(fieldType);
          }
          break;
        default: {
          input.skip(fieldType);
        }
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    if (_args.columns !== undefined && _args.total_byte_size !== undefined && _args.num_rows !== undefined) {
      return new RowGroup(_args);
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read RowGroup from input");
    }
  }
}
export interface IFileMetaDataArgs {
  version: number;
  schema: Array<SchemaElement>;
  num_rows: number | thrift.Int64;
  row_groups: Array<RowGroup>;
  key_value_metadata?: Array<KeyValue>;
  created_by?: string;
}
export class FileMetaData {
  public version: number;
  public schema: Array<SchemaElement>;
  public num_rows: thrift.Int64;
  public row_groups: Array<RowGroup>;
  public key_value_metadata?: Array<KeyValue>;
  public created_by?: string;
  constructor(args: IFileMetaDataArgs) {
    if (args != null && args.version != null) {
      this.version = args.version;
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[version] is unset!");
    }
    if (args != null && args.schema != null) {
      this.schema = args.schema;
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[schema] is unset!");
    }
    if (args != null && args.num_rows != null) {
      if (typeof args.num_rows === "number") {
        this.num_rows = new thrift.Int64(args.num_rows);
      }
      else {
        this.num_rows = args.num_rows;
      }
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[num_rows] is unset!");
    }
    if (args != null && args.row_groups != null) {
      this.row_groups = args.row_groups;
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[row_groups] is unset!");
    }
    if (args != null && args.key_value_metadata != null) {
      this.key_value_metadata = args.key_value_metadata;
    }
    if (args != null && args.created_by != null) {
      this.created_by = args.created_by;
    }
  }
  public write(output: thrift.TProtocol): void {
    output.writeStructBegin("FileMetaData");
    if (this.version != null) {
      output.writeFieldBegin("version", thrift.Thrift.Type.I32, 1);
      output.writeI32(this.version);
      output.writeFieldEnd();
    }
    if (this.schema != null) {
      output.writeFieldBegin("schema", thrift.Thrift.Type.LIST, 2);
      output.writeListBegin(thrift.Thrift.Type.STRUCT, this.schema.length);
      this.schema.forEach((value_78: SchemaElement): void => {
        value_78.write(output);
      });
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.num_rows != null) {
      output.writeFieldBegin("num_rows", thrift.Thrift.Type.I64, 3);
      output.writeI64(this.num_rows);
      output.writeFieldEnd();
    }
    if (this.row_groups != null) {
      output.writeFieldBegin("row_groups", thrift.Thrift.Type.LIST, 4);
      output.writeListBegin(thrift.Thrift.Type.STRUCT, this.row_groups.length);
      this.row_groups.forEach((value_79: RowGroup): void => {
        value_79.write(output);
      });
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.key_value_metadata != null) {
      output.writeFieldBegin("key_value_metadata", thrift.Thrift.Type.LIST, 5);
      output.writeListBegin(thrift.Thrift.Type.STRUCT, this.key_value_metadata.length);
      this.key_value_metadata.forEach((value_80: KeyValue): void => {
        value_80.write(output);
      });
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.created_by != null) {
      output.writeFieldBegin("created_by", thrift.Thrift.Type.STRING, 6);
      output.writeString(this.created_by);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
  public static read(input: thrift.TProtocol): FileMetaData {
    input.readStructBegin();
    let _args: any = {};
    while (true) {
      const ret: thrift.TField = input.readFieldBegin();
      const fieldType: thrift.Thrift.Type = ret.ftype;
      const fieldId: number = ret.fid;
      if (fieldType === thrift.Thrift.Type.STOP) {
        break;
      }
      switch (fieldId) {
        case 1:
          if (fieldType === thrift.Thrift.Type.I32) {
            const value_81: number = input.readI32();
            _args.version = value_81;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 2:
          if (fieldType === thrift.Thrift.Type.LIST) {
            const value_82: Array<SchemaElement> = new Array<SchemaElement>();
            const metadata_7: thrift.TList = input.readListBegin();
            const size_7: number = metadata_7.size;
            for (let i_7: number = 0; i_7 < size_7; i_7++) {
              const value_83: SchemaElement = SchemaElement.read(input);
              value_82.push(value_83);
            }
            input.readListEnd();
            _args.schema = value_82;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 3:
          if (fieldType === thrift.Thrift.Type.I64) {
            const value_84: thrift.Int64 = input.readI64();
            _args.num_rows = value_84;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 4:
          if (fieldType === thrift.Thrift.Type.LIST) {
            const value_85: Array<RowGroup> = new Array<RowGroup>();
            const metadata_8: thrift.TList = input.readListBegin();
            const size_8: number = metadata_8.size;
            for (let i_8: number = 0; i_8 < size_8; i_8++) {
              const value_86: RowGroup = RowGroup.read(input);
              value_85.push(value_86);
            }
            input.readListEnd();
            _args.row_groups = value_85;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 5:
          if (fieldType === thrift.Thrift.Type.LIST) {
            const value_87: Array<KeyValue> = new Array<KeyValue>();
            const metadata_9: thrift.TList = input.readListBegin();
            const size_9: number = metadata_9.size;
            for (let i_9: number = 0; i_9 < size_9; i_9++) {
              const value_88: KeyValue = KeyValue.read(input);
              value_87.push(value_88);
            }
            input.readListEnd();
            _args.key_value_metadata = value_87;
          }
          else {
            input.skip(fieldType);
          }
          break;
        case 6:
          if (fieldType === thrift.Thrift.Type.STRING) {
            const value_89: string = input.readString();
            _args.created_by = value_89;
          }
          else {
            input.skip(fieldType);
          }
          break;
        default: {
          input.skip(fieldType);
        }
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    if (_args.version !== undefined && _args.schema !== undefined && _args.num_rows !== undefined && _args.row_groups !== undefined) {
      return new FileMetaData(_args);
    }
    else {
      throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read FileMetaData from input");
    }
  }
}
