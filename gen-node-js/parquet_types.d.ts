//
// Autogenerated by Thrift Compiler (0.11.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//

/**
 * Types supported by Parquet.  These types are intended to be used in combination
 * with the encodings to control the on disk storage format.
 * For example INT16 is not included as a type since a good encoding of INT32
 * would handle this.
 */
export declare enum Type {
  BOOLEAN = 0,
  INT32 = 1,
  INT64 = 2,
  INT96 = 3,
  FLOAT = 4,
  DOUBLE = 5,
  BYTE_ARRAY = 6,
  FIXED_LEN_BYTE_ARRAY = 7,
}

/**
 * Common types used by frameworks(e.g. hive, pig) using parquet.  This helps map
 * between types in those frameworks to the base types in parquet.  This is only
 * metadata and not needed to read or write the data.
 */
export declare enum ConvertedType {
  UTF8 = 0,
  MAP = 1,
  MAP_KEY_VALUE = 2,
  LIST = 3,
  ENUM = 4,
  DECIMAL = 5,
  DATE = 6,
  TIME_MILLIS = 7,
  TIME_MICROS = 8,
  TIMESTAMP_MILLIS = 9,
  TIMESTAMP_MICROS = 10,
  UINT_8 = 11,
  UINT_16 = 12,
  UINT_32 = 13,
  UINT_64 = 14,
  INT_8 = 15,
  INT_16 = 16,
  INT_32 = 17,
  INT_64 = 18,
  JSON = 19,
  BSON = 20,
  INTERVAL = 21,
}

/**
 * Representation of Schemas
 */
export declare enum FieldRepetitionType {
  REQUIRED = 0,
  OPTIONAL = 1,
  REPEATED = 2,
}

/**
 * Encodings supported by Parquet.  Not all encodings are valid for all types.  These
 * enums are also used to specify the encoding of definition and repetition levels.
 * See the accompanying doc for the details of the more complicated encodings.
 */
export declare enum Encoding {
  PLAIN = 0,
  PLAIN_DICTIONARY = 2,
  RLE = 3,
  BIT_PACKED = 4,
  DELTA_BINARY_PACKED = 5,
  DELTA_LENGTH_BYTE_ARRAY = 6,
  DELTA_BYTE_ARRAY = 7,
  RLE_DICTIONARY = 8,
}

/**
 * Supported compression algorithms.
 * 
 * Codecs added in 2.4 can be read by readers based on 2.4 and later.
 * Codec support may vary between readers based on the format version and
 * libraries available at runtime. Gzip, Snappy, and LZ4 codecs are
 * widely available, while Zstd and Brotli require additional libraries.
 */
export declare enum CompressionCodec {
  UNCOMPRESSED = 0,
  SNAPPY = 1,
  GZIP = 2,
  LZO = 3,
  BROTLI = 4,
  LZ4 = 5,
  ZSTD = 6,
}

export declare enum PageType {
  DATA_PAGE = 0,
  INDEX_PAGE = 1,
  DICTIONARY_PAGE = 2,
  DATA_PAGE_V2 = 3,
}

/**
 * Enum to annotate whether lists of min/max elements inside ColumnIndex
 * are ordered and if so, in which direction.
 */
export declare enum BoundaryOrder {
  UNORDERED = 0,
  ASCENDING = 1,
  DESCENDING = 2,
}

/**
 * Statistics per row group and per page
 * All fields are optional.
 */
export declare class Statistics {
  max: string;
  min: string;
  null_count: number;
  distinct_count: number;
  max_value: string;
  min_value: string;

  constructor(args?: { max?: string; min?: string; null_count?: number; distinct_count?: number; max_value?: string; min_value?: string; });
}

/**
 * Empty structs to use as logical type annotations
 */
export declare class StringType {
}

export declare class UUIDType {
}

export declare class MapType {
}

export declare class ListType {
}

export declare class EnumType {
}

export declare class DateType {
}

/**
 * Logical type to annotate a column that is always null.
 * 
 * Sometimes when discovering the schema of existing data, values are always
 * null and the physical type can't be determined. This annotation signals
 * the case where the physical type was guessed from all null values.
 */
export declare class NullType {
}

/**
 * Decimal logical type annotation
 * 
 * To maintain forward-compatibility in v1, implementations using this logical
 * type must also set scale and precision on the annotated SchemaElement.
 * 
 * Allowed for physical types: INT32, INT64, FIXED, and BINARY
 */
export declare class DecimalType {
  scale: number;
  precision: number;

  constructor(args?: { scale: number; precision: number; });
}

/**
 * Time units for logical types
 */
export declare class MilliSeconds {
}

export declare class MicroSeconds {
}

export declare class TimeUnit {
  MILLIS: MilliSeconds;
  MICROS: MicroSeconds;

  constructor(args?: { MILLIS?: MilliSeconds; MICROS?: MicroSeconds; });
}

/**
 * Timestamp logical type annotation
 * 
 * Allowed for physical types: INT64
 */
export declare class TimestampType {
  isAdjustedToUTC: boolean;
  unit: TimeUnit;

  constructor(args?: { isAdjustedToUTC: boolean; unit: TimeUnit; });
}

/**
 * Time logical type annotation
 * 
 * Allowed for physical types: INT32 (millis), INT64 (micros)
 */
export declare class TimeType {
  isAdjustedToUTC: boolean;
  unit: TimeUnit;

  constructor(args?: { isAdjustedToUTC: boolean; unit: TimeUnit; });
}

/**
 * Integer logical type annotation
 * 
 * bitWidth must be 8, 16, 32, or 64.
 * 
 * Allowed for physical types: INT32, INT64
 */
export declare class IntType {
  bitWidth: any;
  isSigned: boolean;

  constructor(args?: { bitWidth: any; isSigned: boolean; });
}

/**
 * Embedded JSON logical type annotation
 * 
 * Allowed for physical types: BINARY
 */
export declare class JsonType {
}

/**
 * Embedded BSON logical type annotation
 * 
 * Allowed for physical types: BINARY
 */
export declare class BsonType {
}

/**
 * LogicalType annotations to replace ConvertedType.
 * 
 * To maintain compatibility, implementations using LogicalType for a
 * SchemaElement must also set the corresponding ConvertedType from the
 * following table.
 */
export declare class LogicalType {
  STRING: StringType;
  MAP: MapType;
  LIST: ListType;
  ENUM: EnumType;
  DECIMAL: DecimalType;
  DATE: DateType;
  TIME: TimeType;
  TIMESTAMP: TimestampType;
  INTEGER: IntType;
  UNKNOWN: NullType;
  JSON: JsonType;
  BSON: BsonType;
  UUID: UUIDType;

  constructor(args?: { STRING?: StringType; MAP?: MapType; LIST?: ListType; ENUM?: EnumType; DECIMAL?: DecimalType; DATE?: DateType; TIME?: TimeType; TIMESTAMP?: TimestampType; INTEGER?: IntType; UNKNOWN?: NullType; JSON?: JsonType; BSON?: BsonType; UUID?: UUIDType; });
}

/**
 * Represents a element inside a schema definition.
 *  - if it is a group (inner node) then type is undefined and num_children is defined
 *  - if it is a primitive type (leaf) then type is defined and num_children is undefined
 * the nodes are listed in depth first traversal order.
 */
export declare class SchemaElement {
  type: Type;
  type_length: number;
  repetition_type: FieldRepetitionType;
  name: string;
  num_children: number;
  converted_type: ConvertedType;
  scale: number;
  precision: number;
  field_id: number;
  logicalType: LogicalType;

  constructor(args?: { type?: Type; type_length?: number; repetition_type?: FieldRepetitionType; name: string; num_children?: number; converted_type?: ConvertedType; scale?: number; precision?: number; field_id?: number; logicalType?: LogicalType; });
}

/**
 * Data page header
 */
export declare class DataPageHeader {
  num_values: number;
  encoding: Encoding;
  definition_level_encoding: Encoding;
  repetition_level_encoding: Encoding;
  statistics: Statistics;

  constructor(args?: { num_values: number; encoding: Encoding; definition_level_encoding: Encoding; repetition_level_encoding: Encoding; statistics?: Statistics; });
}

export declare class IndexPageHeader {
}

/**
 * TODO: *
 */
export declare class DictionaryPageHeader {
  num_values: number;
  encoding: Encoding;
  is_sorted: boolean;

  constructor(args?: { num_values: number; encoding: Encoding; is_sorted?: boolean; });
}

/**
 * New page format allowing reading levels without decompressing the data
 * Repetition and definition levels are uncompressed
 * The remaining section containing the data is compressed if is_compressed is true
 * 
 */
export declare class DataPageHeaderV2 {
  num_values: number;
  num_nulls: number;
  num_rows: number;
  encoding: Encoding;
  definition_levels_byte_length: number;
  repetition_levels_byte_length: number;
  is_compressed: boolean;
  statistics: Statistics;

  constructor(args?: { num_values: number; num_nulls: number; num_rows: number; encoding: Encoding; definition_levels_byte_length: number; repetition_levels_byte_length: number; is_compressed?: boolean; statistics?: Statistics; });
}

export declare class PageHeader {
  type: PageType;
  uncompressed_page_size: number;
  compressed_page_size: number;
  crc: number;
  data_page_header: DataPageHeader;
  index_page_header: IndexPageHeader;
  dictionary_page_header: DictionaryPageHeader;
  data_page_header_v2: DataPageHeaderV2;

  constructor(args?: { type: PageType; uncompressed_page_size: number; compressed_page_size: number; crc?: number; data_page_header?: DataPageHeader; index_page_header?: IndexPageHeader; dictionary_page_header?: DictionaryPageHeader; data_page_header_v2?: DataPageHeaderV2; });
}

/**
 * Wrapper struct to store key values
 */
export declare class KeyValue {
  key: string;
  value: string;

  constructor(args?: { key: string; value?: string; });
}

/**
 * Wrapper struct to specify sort order
 */
export declare class SortingColumn {
  column_idx: number;
  descending: boolean;
  nulls_first: boolean;

  constructor(args?: { column_idx: number; descending: boolean; nulls_first: boolean; });
}

/**
 * statistics of a given page type and encoding
 */
export declare class PageEncodingStats {
  page_type: PageType;
  encoding: Encoding;
  count: number;

  constructor(args?: { page_type: PageType; encoding: Encoding; count: number; });
}

/**
 * Description for column metadata
 */
export declare class ColumnMetaData {
  type: Type;
  encodings: Encoding[];
  path_in_schema: string[];
  codec: CompressionCodec;
  num_values: number;
  total_uncompressed_size: number;
  total_compressed_size: number;
  key_value_metadata: KeyValue[];
  data_page_offset: number;
  index_page_offset: number;
  dictionary_page_offset: number;
  statistics: Statistics;
  encoding_stats: PageEncodingStats[];

  constructor(args?: { type: Type; encodings: Encoding[]; path_in_schema: string[]; codec: CompressionCodec; num_values: number; total_uncompressed_size: number; total_compressed_size: number; key_value_metadata?: KeyValue[]; data_page_offset: number; index_page_offset?: number; dictionary_page_offset?: number; statistics?: Statistics; encoding_stats?: PageEncodingStats[]; });
}

export declare class ColumnChunk {
  file_path: string;
  file_offset: number;
  meta_data: ColumnMetaData;
  offset_index_offset: number;
  offset_index_length: number;
  column_index_offset: number;
  column_index_length: number;

  constructor(args?: { file_path?: string; file_offset: number; meta_data?: ColumnMetaData; offset_index_offset?: number; offset_index_length?: number; column_index_offset?: number; column_index_length?: number; });
}

export declare class RowGroup {
  columns: ColumnChunk[];
  total_byte_size: number;
  num_rows: number;
  sorting_columns: SortingColumn[];

  constructor(args?: { columns: ColumnChunk[]; total_byte_size: number; num_rows: number; sorting_columns?: SortingColumn[]; });
}

/**
 * Empty struct to signal the order defined by the physical or logical type
 */
export declare class TypeDefinedOrder {
}

/**
 * Union to specify the order used for the min_value and max_value fields for a
 * column. This union takes the role of an enhanced enum that allows rich
 * elements (which will be needed for a collation-based ordering in the future).
 * 
 * Possible values are:
 * * TypeDefinedOrder - the column uses the order defined by its logical or
 *                      physical type (if there is no logical type).
 * 
 * If the reader does not support the value of this union, min and max stats
 * for this column should be ignored.
 */
export declare class ColumnOrder {
  TYPE_ORDER: TypeDefinedOrder;

  constructor(args?: { TYPE_ORDER?: TypeDefinedOrder; });
}

export declare class PageLocation {
  offset: number;
  compressed_page_size: number;
  first_row_index: number;

  constructor(args?: { offset: number; compressed_page_size: number; first_row_index: number; });
}

export declare class OffsetIndex {
  page_locations: PageLocation[];

  constructor(args?: { page_locations: PageLocation[]; });
}

/**
 * Description for ColumnIndex.
 * Each <array-field>[i] refers to the page at OffsetIndex.page_locations[i]
 */
export declare class ColumnIndex {
  null_pages: boolean[];
  min_values: string[];
  max_values: string[];
  boundary_order: BoundaryOrder;
  null_counts: number[];

  constructor(args?: { null_pages: boolean[]; min_values: string[]; max_values: string[]; boundary_order: BoundaryOrder; null_counts?: number[]; });
}

/**
 * Description for file metadata
 */
export declare class FileMetaData {
  version: number;
  schema: SchemaElement[];
  num_rows: number;
  row_groups: RowGroup[];
  key_value_metadata: KeyValue[];
  created_by: string;
  column_orders: ColumnOrder[];

  constructor(args?: { version: number; schema: SchemaElement[]; num_rows: number; row_groups: RowGroup[]; key_value_metadata?: KeyValue[]; created_by?: string; column_orders?: ColumnOrder[]; });
}
