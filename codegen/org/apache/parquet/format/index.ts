/* tslint:disable */
/*
 * Autogenerated by @creditkarma/thrift-typescript v2.0.0
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
*/
import * as thrift from "thrift";
export enum Type {
    BOOLEAN = 0,
    INT32 = 1,
    INT64 = 2,
    INT96 = 3,
    FLOAT = 4,
    DOUBLE = 5,
    BYTE_ARRAY = 6,
    FIXED_LEN_BYTE_ARRAY = 7
}
export enum ConvertedType {
    UTF8 = 0,
    MAP = 1,
    MAP_KEY_VALUE = 2,
    LIST = 3,
    ENUM = 4,
    DECIMAL = 5,
    DATE = 6,
    TIME_MILLIS = 7,
    TIME_MICROS = 8,
    TIMESTAMP_MILLIS = 9,
    TIMESTAMP_MICROS = 10,
    UINT_8 = 11,
    UINT_16 = 12,
    UINT_32 = 13,
    UINT_64 = 14,
    INT_8 = 15,
    INT_16 = 16,
    INT_32 = 17,
    INT_64 = 18,
    JSON = 19,
    BSON = 20,
    INTERVAL = 21
}
export enum FieldRepetitionType {
    REQUIRED = 0,
    OPTIONAL = 1,
    REPEATED = 2
}
export enum Encoding {
    PLAIN = 0,
    PLAIN_DICTIONARY = 2,
    RLE = 3,
    BIT_PACKED = 4,
    DELTA_BINARY_PACKED = 5,
    DELTA_LENGTH_BYTE_ARRAY = 6,
    DELTA_BYTE_ARRAY = 7,
    RLE_DICTIONARY = 8
}
export enum CompressionCodec {
    UNCOMPRESSED = 0,
    SNAPPY = 1,
    GZIP = 2,
    LZO = 3,
    BROTLI = 4,
    LZ4 = 5,
    ZSTD = 6
}
export enum PageType {
    DATA_PAGE = 0,
    INDEX_PAGE = 1,
    DICTIONARY_PAGE = 2,
    DATA_PAGE_V2 = 3
}
export enum BoundaryOrder {
    UNORDERED = 0,
    ASCENDING = 1,
    DESCENDING = 2
}
export interface IStatisticsArgs {
    max?: Buffer;
    min?: Buffer;
    null_count?: number | thrift.Int64;
    distinct_count?: number | thrift.Int64;
    max_value?: Buffer;
    min_value?: Buffer;
}
export class Statistics {
    public max?: Buffer;
    public min?: Buffer;
    public null_count?: thrift.Int64;
    public distinct_count?: thrift.Int64;
    public max_value?: Buffer;
    public min_value?: Buffer;
    constructor(args?: IStatisticsArgs) {
        if (args != null && args.max != null) {
            this.max = args.max;
        }
        if (args != null && args.min != null) {
            this.min = args.min;
        }
        if (args != null && args.null_count != null) {
            if (typeof args.null_count === "number") {
                this.null_count = new thrift.Int64(args.null_count);
            }
            else {
                this.null_count = args.null_count;
            }
        }
        if (args != null && args.distinct_count != null) {
            if (typeof args.distinct_count === "number") {
                this.distinct_count = new thrift.Int64(args.distinct_count);
            }
            else {
                this.distinct_count = args.distinct_count;
            }
        }
        if (args != null && args.max_value != null) {
            this.max_value = args.max_value;
        }
        if (args != null && args.min_value != null) {
            this.min_value = args.min_value;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("Statistics");
        if (this.max != null) {
            output.writeFieldBegin("max", thrift.Thrift.Type.STRING, 1);
            output.writeBinary(this.max);
            output.writeFieldEnd();
        }
        if (this.min != null) {
            output.writeFieldBegin("min", thrift.Thrift.Type.STRING, 2);
            output.writeBinary(this.min);
            output.writeFieldEnd();
        }
        if (this.null_count != null) {
            output.writeFieldBegin("null_count", thrift.Thrift.Type.I64, 3);
            output.writeI64(this.null_count);
            output.writeFieldEnd();
        }
        if (this.distinct_count != null) {
            output.writeFieldBegin("distinct_count", thrift.Thrift.Type.I64, 4);
            output.writeI64(this.distinct_count);
            output.writeFieldEnd();
        }
        if (this.max_value != null) {
            output.writeFieldBegin("max_value", thrift.Thrift.Type.STRING, 5);
            output.writeBinary(this.max_value);
            output.writeFieldEnd();
        }
        if (this.min_value != null) {
            output.writeFieldBegin("min_value", thrift.Thrift.Type.STRING, 6);
            output.writeBinary(this.min_value);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): Statistics {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_1: Buffer = input.readBinary();
                        _args.max = value_1;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_2: Buffer = input.readBinary();
                        _args.min = value_2;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.I64) {
                        const value_3: thrift.Int64 = input.readI64();
                        _args.null_count = value_3;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.I64) {
                        const value_4: thrift.Int64 = input.readI64();
                        _args.distinct_count = value_4;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_5: Buffer = input.readBinary();
                        _args.max_value = value_5;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 6:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_6: Buffer = input.readBinary();
                        _args.min_value = value_6;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new Statistics(_args);
    }
}
export interface IStringTypeArgs {
}
export class StringType {
    constructor() {
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("StringType");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): StringType {
        input.readStructBegin();
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new StringType();
    }
}
export interface IUUIDTypeArgs {
}
export class UUIDType {
    constructor() {
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("UUIDType");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): UUIDType {
        input.readStructBegin();
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new UUIDType();
    }
}
export interface IMapTypeArgs {
}
export class MapType {
    constructor() {
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("MapType");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): MapType {
        input.readStructBegin();
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new MapType();
    }
}
export interface IListTypeArgs {
}
export class ListType {
    constructor() {
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ListType");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ListType {
        input.readStructBegin();
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ListType();
    }
}
export interface IEnumTypeArgs {
}
export class EnumType {
    constructor() {
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("EnumType");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): EnumType {
        input.readStructBegin();
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new EnumType();
    }
}
export interface IDateTypeArgs {
}
export class DateType {
    constructor() {
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DateType");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DateType {
        input.readStructBegin();
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new DateType();
    }
}
export interface INullTypeArgs {
}
export class NullType {
    constructor() {
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("NullType");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): NullType {
        input.readStructBegin();
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new NullType();
    }
}
export interface IDecimalTypeArgs {
    scale: number;
    precision: number;
}
export class DecimalType {
    public scale: number;
    public precision: number;
    constructor(args: IDecimalTypeArgs) {
        if (args != null && args.scale != null) {
            this.scale = args.scale;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[scale] is unset!");
        }
        if (args != null && args.precision != null) {
            this.precision = args.precision;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[precision] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DecimalType");
        if (this.scale != null) {
            output.writeFieldBegin("scale", thrift.Thrift.Type.I32, 1);
            output.writeI32(this.scale);
            output.writeFieldEnd();
        }
        if (this.precision != null) {
            output.writeFieldBegin("precision", thrift.Thrift.Type.I32, 2);
            output.writeI32(this.precision);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DecimalType {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_7: number = input.readI32();
                        _args.scale = value_7;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_8: number = input.readI32();
                        _args.precision = value_8;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.scale !== undefined && _args.precision !== undefined) {
            return new DecimalType(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read DecimalType from input");
        }
    }
}
export interface IMilliSecondsArgs {
}
export class MilliSeconds {
    constructor() {
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("MilliSeconds");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): MilliSeconds {
        input.readStructBegin();
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new MilliSeconds();
    }
}
export interface IMicroSecondsArgs {
}
export class MicroSeconds {
    constructor() {
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("MicroSeconds");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): MicroSeconds {
        input.readStructBegin();
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new MicroSeconds();
    }
}
export interface ITimestampTypeArgs {
    isAdjustedToUTC: boolean;
    unit: TimeUnit;
}
export class TimestampType {
    public isAdjustedToUTC: boolean;
    public unit: TimeUnit;
    constructor(args: ITimestampTypeArgs) {
        if (args != null && args.isAdjustedToUTC != null) {
            this.isAdjustedToUTC = args.isAdjustedToUTC;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[isAdjustedToUTC] is unset!");
        }
        if (args != null && args.unit != null) {
            this.unit = args.unit;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[unit] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("TimestampType");
        if (this.isAdjustedToUTC != null) {
            output.writeFieldBegin("isAdjustedToUTC", thrift.Thrift.Type.BOOL, 1);
            output.writeBool(this.isAdjustedToUTC);
            output.writeFieldEnd();
        }
        if (this.unit != null) {
            output.writeFieldBegin("unit", thrift.Thrift.Type.STRUCT, 2);
            this.unit.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): TimestampType {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_9: boolean = input.readBool();
                        _args.isAdjustedToUTC = value_9;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_10: TimeUnit = TimeUnit.read(input);
                        _args.unit = value_10;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.isAdjustedToUTC !== undefined && _args.unit !== undefined) {
            return new TimestampType(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read TimestampType from input");
        }
    }
}
export interface ITimeTypeArgs {
    isAdjustedToUTC: boolean;
    unit: TimeUnit;
}
export class TimeType {
    public isAdjustedToUTC: boolean;
    public unit: TimeUnit;
    constructor(args: ITimeTypeArgs) {
        if (args != null && args.isAdjustedToUTC != null) {
            this.isAdjustedToUTC = args.isAdjustedToUTC;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[isAdjustedToUTC] is unset!");
        }
        if (args != null && args.unit != null) {
            this.unit = args.unit;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[unit] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("TimeType");
        if (this.isAdjustedToUTC != null) {
            output.writeFieldBegin("isAdjustedToUTC", thrift.Thrift.Type.BOOL, 1);
            output.writeBool(this.isAdjustedToUTC);
            output.writeFieldEnd();
        }
        if (this.unit != null) {
            output.writeFieldBegin("unit", thrift.Thrift.Type.STRUCT, 2);
            this.unit.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): TimeType {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_11: boolean = input.readBool();
                        _args.isAdjustedToUTC = value_11;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_12: TimeUnit = TimeUnit.read(input);
                        _args.unit = value_12;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.isAdjustedToUTC !== undefined && _args.unit !== undefined) {
            return new TimeType(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read TimeType from input");
        }
    }
}
export interface IIntTypeArgs {
    bitWidth: number;
    isSigned: boolean;
}
export class IntType {
    public bitWidth: number;
    public isSigned: boolean;
    constructor(args: IIntTypeArgs) {
        if (args != null && args.bitWidth != null) {
            this.bitWidth = args.bitWidth;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[bitWidth] is unset!");
        }
        if (args != null && args.isSigned != null) {
            this.isSigned = args.isSigned;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[isSigned] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("IntType");
        if (this.bitWidth != null) {
            output.writeFieldBegin("bitWidth", thrift.Thrift.Type.BYTE, 1);
            output.writeByte(this.bitWidth);
            output.writeFieldEnd();
        }
        if (this.isSigned != null) {
            output.writeFieldBegin("isSigned", thrift.Thrift.Type.BOOL, 2);
            output.writeBool(this.isSigned);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): IntType {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.BYTE) {
                        const value_13: number = input.readByte();
                        _args.bitWidth = value_13;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_14: boolean = input.readBool();
                        _args.isSigned = value_14;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.bitWidth !== undefined && _args.isSigned !== undefined) {
            return new IntType(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read IntType from input");
        }
    }
}
export interface IJsonTypeArgs {
}
export class JsonType {
    constructor() {
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("JsonType");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): JsonType {
        input.readStructBegin();
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new JsonType();
    }
}
export interface IBsonTypeArgs {
}
export class BsonType {
    constructor() {
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("BsonType");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): BsonType {
        input.readStructBegin();
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new BsonType();
    }
}
export interface ISchemaElementArgs {
    type?: Type;
    type_length?: number;
    repetition_type?: FieldRepetitionType;
    name: string;
    num_children?: number;
    converted_type?: ConvertedType;
    scale?: number;
    precision?: number;
    field_id?: number;
    logicalType?: LogicalType;
}
export class SchemaElement {
    public type?: Type;
    public type_length?: number;
    public repetition_type?: FieldRepetitionType;
    public name: string;
    public num_children?: number;
    public converted_type?: ConvertedType;
    public scale?: number;
    public precision?: number;
    public field_id?: number;
    public logicalType?: LogicalType;
    constructor(args: ISchemaElementArgs) {
        if (args != null && args.type != null) {
            this.type = args.type;
        }
        if (args != null && args.type_length != null) {
            this.type_length = args.type_length;
        }
        if (args != null && args.repetition_type != null) {
            this.repetition_type = args.repetition_type;
        }
        if (args != null && args.name != null) {
            this.name = args.name;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[name] is unset!");
        }
        if (args != null && args.num_children != null) {
            this.num_children = args.num_children;
        }
        if (args != null && args.converted_type != null) {
            this.converted_type = args.converted_type;
        }
        if (args != null && args.scale != null) {
            this.scale = args.scale;
        }
        if (args != null && args.precision != null) {
            this.precision = args.precision;
        }
        if (args != null && args.field_id != null) {
            this.field_id = args.field_id;
        }
        if (args != null && args.logicalType != null) {
            this.logicalType = args.logicalType;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SchemaElement");
        if (this.type != null) {
            output.writeFieldBegin("type", thrift.Thrift.Type.I32, 1);
            output.writeI32(this.type);
            output.writeFieldEnd();
        }
        if (this.type_length != null) {
            output.writeFieldBegin("type_length", thrift.Thrift.Type.I32, 2);
            output.writeI32(this.type_length);
            output.writeFieldEnd();
        }
        if (this.repetition_type != null) {
            output.writeFieldBegin("repetition_type", thrift.Thrift.Type.I32, 3);
            output.writeI32(this.repetition_type);
            output.writeFieldEnd();
        }
        if (this.name != null) {
            output.writeFieldBegin("name", thrift.Thrift.Type.STRING, 4);
            output.writeString(this.name);
            output.writeFieldEnd();
        }
        if (this.num_children != null) {
            output.writeFieldBegin("num_children", thrift.Thrift.Type.I32, 5);
            output.writeI32(this.num_children);
            output.writeFieldEnd();
        }
        if (this.converted_type != null) {
            output.writeFieldBegin("converted_type", thrift.Thrift.Type.I32, 6);
            output.writeI32(this.converted_type);
            output.writeFieldEnd();
        }
        if (this.scale != null) {
            output.writeFieldBegin("scale", thrift.Thrift.Type.I32, 7);
            output.writeI32(this.scale);
            output.writeFieldEnd();
        }
        if (this.precision != null) {
            output.writeFieldBegin("precision", thrift.Thrift.Type.I32, 8);
            output.writeI32(this.precision);
            output.writeFieldEnd();
        }
        if (this.field_id != null) {
            output.writeFieldBegin("field_id", thrift.Thrift.Type.I32, 9);
            output.writeI32(this.field_id);
            output.writeFieldEnd();
        }
        if (this.logicalType != null) {
            output.writeFieldBegin("logicalType", thrift.Thrift.Type.STRUCT, 10);
            this.logicalType.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SchemaElement {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_15: Type = input.readI32();
                        _args.type = value_15;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_16: number = input.readI32();
                        _args.type_length = value_16;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_17: FieldRepetitionType = input.readI32();
                        _args.repetition_type = value_17;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_18: string = input.readString();
                        _args.name = value_18;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_19: number = input.readI32();
                        _args.num_children = value_19;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 6:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_20: ConvertedType = input.readI32();
                        _args.converted_type = value_20;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 7:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_21: number = input.readI32();
                        _args.scale = value_21;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 8:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_22: number = input.readI32();
                        _args.precision = value_22;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 9:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_23: number = input.readI32();
                        _args.field_id = value_23;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 10:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_24: LogicalType = LogicalType.read(input);
                        _args.logicalType = value_24;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.name !== undefined) {
            return new SchemaElement(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read SchemaElement from input");
        }
    }
}
export interface IDataPageHeaderArgs {
    num_values: number;
    encoding: Encoding;
    definition_level_encoding: Encoding;
    repetition_level_encoding: Encoding;
    statistics?: Statistics;
}
export class DataPageHeader {
    public num_values: number;
    public encoding: Encoding;
    public definition_level_encoding: Encoding;
    public repetition_level_encoding: Encoding;
    public statistics?: Statistics;
    constructor(args: IDataPageHeaderArgs) {
        if (args != null && args.num_values != null) {
            this.num_values = args.num_values;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[num_values] is unset!");
        }
        if (args != null && args.encoding != null) {
            this.encoding = args.encoding;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[encoding] is unset!");
        }
        if (args != null && args.definition_level_encoding != null) {
            this.definition_level_encoding = args.definition_level_encoding;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[definition_level_encoding] is unset!");
        }
        if (args != null && args.repetition_level_encoding != null) {
            this.repetition_level_encoding = args.repetition_level_encoding;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[repetition_level_encoding] is unset!");
        }
        if (args != null && args.statistics != null) {
            this.statistics = args.statistics;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DataPageHeader");
        if (this.num_values != null) {
            output.writeFieldBegin("num_values", thrift.Thrift.Type.I32, 1);
            output.writeI32(this.num_values);
            output.writeFieldEnd();
        }
        if (this.encoding != null) {
            output.writeFieldBegin("encoding", thrift.Thrift.Type.I32, 2);
            output.writeI32(this.encoding);
            output.writeFieldEnd();
        }
        if (this.definition_level_encoding != null) {
            output.writeFieldBegin("definition_level_encoding", thrift.Thrift.Type.I32, 3);
            output.writeI32(this.definition_level_encoding);
            output.writeFieldEnd();
        }
        if (this.repetition_level_encoding != null) {
            output.writeFieldBegin("repetition_level_encoding", thrift.Thrift.Type.I32, 4);
            output.writeI32(this.repetition_level_encoding);
            output.writeFieldEnd();
        }
        if (this.statistics != null) {
            output.writeFieldBegin("statistics", thrift.Thrift.Type.STRUCT, 5);
            this.statistics.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DataPageHeader {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_25: number = input.readI32();
                        _args.num_values = value_25;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_26: Encoding = input.readI32();
                        _args.encoding = value_26;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_27: Encoding = input.readI32();
                        _args.definition_level_encoding = value_27;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_28: Encoding = input.readI32();
                        _args.repetition_level_encoding = value_28;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_29: Statistics = Statistics.read(input);
                        _args.statistics = value_29;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.num_values !== undefined && _args.encoding !== undefined && _args.definition_level_encoding !== undefined && _args.repetition_level_encoding !== undefined) {
            return new DataPageHeader(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read DataPageHeader from input");
        }
    }
}
export interface IIndexPageHeaderArgs {
}
export class IndexPageHeader {
    constructor() {
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("IndexPageHeader");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): IndexPageHeader {
        input.readStructBegin();
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new IndexPageHeader();
    }
}
export interface IDictionaryPageHeaderArgs {
    num_values: number;
    encoding: Encoding;
    is_sorted?: boolean;
}
export class DictionaryPageHeader {
    public num_values: number;
    public encoding: Encoding;
    public is_sorted?: boolean;
    constructor(args: IDictionaryPageHeaderArgs) {
        if (args != null && args.num_values != null) {
            this.num_values = args.num_values;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[num_values] is unset!");
        }
        if (args != null && args.encoding != null) {
            this.encoding = args.encoding;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[encoding] is unset!");
        }
        if (args != null && args.is_sorted != null) {
            this.is_sorted = args.is_sorted;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DictionaryPageHeader");
        if (this.num_values != null) {
            output.writeFieldBegin("num_values", thrift.Thrift.Type.I32, 1);
            output.writeI32(this.num_values);
            output.writeFieldEnd();
        }
        if (this.encoding != null) {
            output.writeFieldBegin("encoding", thrift.Thrift.Type.I32, 2);
            output.writeI32(this.encoding);
            output.writeFieldEnd();
        }
        if (this.is_sorted != null) {
            output.writeFieldBegin("is_sorted", thrift.Thrift.Type.BOOL, 3);
            output.writeBool(this.is_sorted);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DictionaryPageHeader {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_30: number = input.readI32();
                        _args.num_values = value_30;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_31: Encoding = input.readI32();
                        _args.encoding = value_31;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_32: boolean = input.readBool();
                        _args.is_sorted = value_32;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.num_values !== undefined && _args.encoding !== undefined) {
            return new DictionaryPageHeader(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read DictionaryPageHeader from input");
        }
    }
}
export interface IDataPageHeaderV2Args {
    num_values: number;
    num_nulls: number;
    num_rows: number;
    encoding: Encoding;
    definition_levels_byte_length: number;
    repetition_levels_byte_length: number;
    is_compressed?: boolean;
    statistics?: Statistics;
}
export class DataPageHeaderV2 {
    public num_values: number;
    public num_nulls: number;
    public num_rows: number;
    public encoding: Encoding;
    public definition_levels_byte_length: number;
    public repetition_levels_byte_length: number;
    public is_compressed?: boolean = true;
    public statistics?: Statistics;
    constructor(args: IDataPageHeaderV2Args) {
        if (args != null && args.num_values != null) {
            this.num_values = args.num_values;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[num_values] is unset!");
        }
        if (args != null && args.num_nulls != null) {
            this.num_nulls = args.num_nulls;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[num_nulls] is unset!");
        }
        if (args != null && args.num_rows != null) {
            this.num_rows = args.num_rows;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[num_rows] is unset!");
        }
        if (args != null && args.encoding != null) {
            this.encoding = args.encoding;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[encoding] is unset!");
        }
        if (args != null && args.definition_levels_byte_length != null) {
            this.definition_levels_byte_length = args.definition_levels_byte_length;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[definition_levels_byte_length] is unset!");
        }
        if (args != null && args.repetition_levels_byte_length != null) {
            this.repetition_levels_byte_length = args.repetition_levels_byte_length;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[repetition_levels_byte_length] is unset!");
        }
        if (args != null && args.is_compressed != null) {
            this.is_compressed = args.is_compressed;
        }
        if (args != null && args.statistics != null) {
            this.statistics = args.statistics;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DataPageHeaderV2");
        if (this.num_values != null) {
            output.writeFieldBegin("num_values", thrift.Thrift.Type.I32, 1);
            output.writeI32(this.num_values);
            output.writeFieldEnd();
        }
        if (this.num_nulls != null) {
            output.writeFieldBegin("num_nulls", thrift.Thrift.Type.I32, 2);
            output.writeI32(this.num_nulls);
            output.writeFieldEnd();
        }
        if (this.num_rows != null) {
            output.writeFieldBegin("num_rows", thrift.Thrift.Type.I32, 3);
            output.writeI32(this.num_rows);
            output.writeFieldEnd();
        }
        if (this.encoding != null) {
            output.writeFieldBegin("encoding", thrift.Thrift.Type.I32, 4);
            output.writeI32(this.encoding);
            output.writeFieldEnd();
        }
        if (this.definition_levels_byte_length != null) {
            output.writeFieldBegin("definition_levels_byte_length", thrift.Thrift.Type.I32, 5);
            output.writeI32(this.definition_levels_byte_length);
            output.writeFieldEnd();
        }
        if (this.repetition_levels_byte_length != null) {
            output.writeFieldBegin("repetition_levels_byte_length", thrift.Thrift.Type.I32, 6);
            output.writeI32(this.repetition_levels_byte_length);
            output.writeFieldEnd();
        }
        if (this.is_compressed != null) {
            output.writeFieldBegin("is_compressed", thrift.Thrift.Type.BOOL, 7);
            output.writeBool(this.is_compressed);
            output.writeFieldEnd();
        }
        if (this.statistics != null) {
            output.writeFieldBegin("statistics", thrift.Thrift.Type.STRUCT, 8);
            this.statistics.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DataPageHeaderV2 {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_33: number = input.readI32();
                        _args.num_values = value_33;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_34: number = input.readI32();
                        _args.num_nulls = value_34;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_35: number = input.readI32();
                        _args.num_rows = value_35;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_36: Encoding = input.readI32();
                        _args.encoding = value_36;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_37: number = input.readI32();
                        _args.definition_levels_byte_length = value_37;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 6:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_38: number = input.readI32();
                        _args.repetition_levels_byte_length = value_38;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 7:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_39: boolean = input.readBool();
                        _args.is_compressed = value_39;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 8:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_40: Statistics = Statistics.read(input);
                        _args.statistics = value_40;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.num_values !== undefined && _args.num_nulls !== undefined && _args.num_rows !== undefined && _args.encoding !== undefined && _args.definition_levels_byte_length !== undefined && _args.repetition_levels_byte_length !== undefined) {
            return new DataPageHeaderV2(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read DataPageHeaderV2 from input");
        }
    }
}
export interface IPageHeaderArgs {
    type: PageType;
    uncompressed_page_size: number;
    compressed_page_size: number;
    crc?: number;
    data_page_header?: DataPageHeader;
    index_page_header?: IndexPageHeader;
    dictionary_page_header?: DictionaryPageHeader;
    data_page_header_v2?: DataPageHeaderV2;
}
export class PageHeader {
    public type: PageType;
    public uncompressed_page_size: number;
    public compressed_page_size: number;
    public crc?: number;
    public data_page_header?: DataPageHeader;
    public index_page_header?: IndexPageHeader;
    public dictionary_page_header?: DictionaryPageHeader;
    public data_page_header_v2?: DataPageHeaderV2;
    constructor(args: IPageHeaderArgs) {
        if (args != null && args.type != null) {
            this.type = args.type;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[type] is unset!");
        }
        if (args != null && args.uncompressed_page_size != null) {
            this.uncompressed_page_size = args.uncompressed_page_size;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[uncompressed_page_size] is unset!");
        }
        if (args != null && args.compressed_page_size != null) {
            this.compressed_page_size = args.compressed_page_size;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[compressed_page_size] is unset!");
        }
        if (args != null && args.crc != null) {
            this.crc = args.crc;
        }
        if (args != null && args.data_page_header != null) {
            this.data_page_header = args.data_page_header;
        }
        if (args != null && args.index_page_header != null) {
            this.index_page_header = args.index_page_header;
        }
        if (args != null && args.dictionary_page_header != null) {
            this.dictionary_page_header = args.dictionary_page_header;
        }
        if (args != null && args.data_page_header_v2 != null) {
            this.data_page_header_v2 = args.data_page_header_v2;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("PageHeader");
        if (this.type != null) {
            output.writeFieldBegin("type", thrift.Thrift.Type.I32, 1);
            output.writeI32(this.type);
            output.writeFieldEnd();
        }
        if (this.uncompressed_page_size != null) {
            output.writeFieldBegin("uncompressed_page_size", thrift.Thrift.Type.I32, 2);
            output.writeI32(this.uncompressed_page_size);
            output.writeFieldEnd();
        }
        if (this.compressed_page_size != null) {
            output.writeFieldBegin("compressed_page_size", thrift.Thrift.Type.I32, 3);
            output.writeI32(this.compressed_page_size);
            output.writeFieldEnd();
        }
        if (this.crc != null) {
            output.writeFieldBegin("crc", thrift.Thrift.Type.I32, 4);
            output.writeI32(this.crc);
            output.writeFieldEnd();
        }
        if (this.data_page_header != null) {
            output.writeFieldBegin("data_page_header", thrift.Thrift.Type.STRUCT, 5);
            this.data_page_header.write(output);
            output.writeFieldEnd();
        }
        if (this.index_page_header != null) {
            output.writeFieldBegin("index_page_header", thrift.Thrift.Type.STRUCT, 6);
            this.index_page_header.write(output);
            output.writeFieldEnd();
        }
        if (this.dictionary_page_header != null) {
            output.writeFieldBegin("dictionary_page_header", thrift.Thrift.Type.STRUCT, 7);
            this.dictionary_page_header.write(output);
            output.writeFieldEnd();
        }
        if (this.data_page_header_v2 != null) {
            output.writeFieldBegin("data_page_header_v2", thrift.Thrift.Type.STRUCT, 8);
            this.data_page_header_v2.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): PageHeader {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_41: PageType = input.readI32();
                        _args.type = value_41;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_42: number = input.readI32();
                        _args.uncompressed_page_size = value_42;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_43: number = input.readI32();
                        _args.compressed_page_size = value_43;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_44: number = input.readI32();
                        _args.crc = value_44;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_45: DataPageHeader = DataPageHeader.read(input);
                        _args.data_page_header = value_45;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 6:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_46: IndexPageHeader = IndexPageHeader.read(input);
                        _args.index_page_header = value_46;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 7:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_47: DictionaryPageHeader = DictionaryPageHeader.read(input);
                        _args.dictionary_page_header = value_47;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 8:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_48: DataPageHeaderV2 = DataPageHeaderV2.read(input);
                        _args.data_page_header_v2 = value_48;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.type !== undefined && _args.uncompressed_page_size !== undefined && _args.compressed_page_size !== undefined) {
            return new PageHeader(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read PageHeader from input");
        }
    }
}
export interface IKeyValueArgs {
    key: string;
    value?: string;
}
export class KeyValue {
    public key: string;
    public value?: string;
    constructor(args: IKeyValueArgs) {
        if (args != null && args.key != null) {
            this.key = args.key;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[key] is unset!");
        }
        if (args != null && args.value != null) {
            this.value = args.value;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("KeyValue");
        if (this.key != null) {
            output.writeFieldBegin("key", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.key);
            output.writeFieldEnd();
        }
        if (this.value != null) {
            output.writeFieldBegin("value", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.value);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): KeyValue {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_49: string = input.readString();
                        _args.key = value_49;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_50: string = input.readString();
                        _args.value = value_50;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.key !== undefined) {
            return new KeyValue(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read KeyValue from input");
        }
    }
}
export interface ISortingColumnArgs {
    column_idx: number;
    descending: boolean;
    nulls_first: boolean;
}
export class SortingColumn {
    public column_idx: number;
    public descending: boolean;
    public nulls_first: boolean;
    constructor(args: ISortingColumnArgs) {
        if (args != null && args.column_idx != null) {
            this.column_idx = args.column_idx;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[column_idx] is unset!");
        }
        if (args != null && args.descending != null) {
            this.descending = args.descending;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[descending] is unset!");
        }
        if (args != null && args.nulls_first != null) {
            this.nulls_first = args.nulls_first;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[nulls_first] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SortingColumn");
        if (this.column_idx != null) {
            output.writeFieldBegin("column_idx", thrift.Thrift.Type.I32, 1);
            output.writeI32(this.column_idx);
            output.writeFieldEnd();
        }
        if (this.descending != null) {
            output.writeFieldBegin("descending", thrift.Thrift.Type.BOOL, 2);
            output.writeBool(this.descending);
            output.writeFieldEnd();
        }
        if (this.nulls_first != null) {
            output.writeFieldBegin("nulls_first", thrift.Thrift.Type.BOOL, 3);
            output.writeBool(this.nulls_first);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SortingColumn {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_51: number = input.readI32();
                        _args.column_idx = value_51;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_52: boolean = input.readBool();
                        _args.descending = value_52;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_53: boolean = input.readBool();
                        _args.nulls_first = value_53;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.column_idx !== undefined && _args.descending !== undefined && _args.nulls_first !== undefined) {
            return new SortingColumn(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read SortingColumn from input");
        }
    }
}
export interface IPageEncodingStatsArgs {
    page_type: PageType;
    encoding: Encoding;
    count: number;
}
export class PageEncodingStats {
    public page_type: PageType;
    public encoding: Encoding;
    public count: number;
    constructor(args: IPageEncodingStatsArgs) {
        if (args != null && args.page_type != null) {
            this.page_type = args.page_type;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[page_type] is unset!");
        }
        if (args != null && args.encoding != null) {
            this.encoding = args.encoding;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[encoding] is unset!");
        }
        if (args != null && args.count != null) {
            this.count = args.count;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[count] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("PageEncodingStats");
        if (this.page_type != null) {
            output.writeFieldBegin("page_type", thrift.Thrift.Type.I32, 1);
            output.writeI32(this.page_type);
            output.writeFieldEnd();
        }
        if (this.encoding != null) {
            output.writeFieldBegin("encoding", thrift.Thrift.Type.I32, 2);
            output.writeI32(this.encoding);
            output.writeFieldEnd();
        }
        if (this.count != null) {
            output.writeFieldBegin("count", thrift.Thrift.Type.I32, 3);
            output.writeI32(this.count);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): PageEncodingStats {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_54: PageType = input.readI32();
                        _args.page_type = value_54;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_55: Encoding = input.readI32();
                        _args.encoding = value_55;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_56: number = input.readI32();
                        _args.count = value_56;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.page_type !== undefined && _args.encoding !== undefined && _args.count !== undefined) {
            return new PageEncodingStats(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read PageEncodingStats from input");
        }
    }
}
export interface IColumnMetaDataArgs {
    type: Type;
    encodings: Array<Encoding>;
    path_in_schema: Array<string>;
    codec: CompressionCodec;
    num_values: number | thrift.Int64;
    total_uncompressed_size: number | thrift.Int64;
    total_compressed_size: number | thrift.Int64;
    key_value_metadata?: Array<KeyValue>;
    data_page_offset: number | thrift.Int64;
    index_page_offset?: number | thrift.Int64;
    dictionary_page_offset?: number | thrift.Int64;
    statistics?: Statistics;
    encoding_stats?: Array<PageEncodingStats>;
}
export class ColumnMetaData {
    public type: Type;
    public encodings: Array<Encoding>;
    public path_in_schema: Array<string>;
    public codec: CompressionCodec;
    public num_values: thrift.Int64;
    public total_uncompressed_size: thrift.Int64;
    public total_compressed_size: thrift.Int64;
    public key_value_metadata?: Array<KeyValue>;
    public data_page_offset: thrift.Int64;
    public index_page_offset?: thrift.Int64;
    public dictionary_page_offset?: thrift.Int64;
    public statistics?: Statistics;
    public encoding_stats?: Array<PageEncodingStats>;
    constructor(args: IColumnMetaDataArgs) {
        if (args != null && args.type != null) {
            this.type = args.type;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[type] is unset!");
        }
        if (args != null && args.encodings != null) {
            this.encodings = args.encodings;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[encodings] is unset!");
        }
        if (args != null && args.path_in_schema != null) {
            this.path_in_schema = args.path_in_schema;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[path_in_schema] is unset!");
        }
        if (args != null && args.codec != null) {
            this.codec = args.codec;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[codec] is unset!");
        }
        if (args != null && args.num_values != null) {
            if (typeof args.num_values === "number") {
                this.num_values = new thrift.Int64(args.num_values);
            }
            else {
                this.num_values = args.num_values;
            }
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[num_values] is unset!");
        }
        if (args != null && args.total_uncompressed_size != null) {
            if (typeof args.total_uncompressed_size === "number") {
                this.total_uncompressed_size = new thrift.Int64(args.total_uncompressed_size);
            }
            else {
                this.total_uncompressed_size = args.total_uncompressed_size;
            }
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[total_uncompressed_size] is unset!");
        }
        if (args != null && args.total_compressed_size != null) {
            if (typeof args.total_compressed_size === "number") {
                this.total_compressed_size = new thrift.Int64(args.total_compressed_size);
            }
            else {
                this.total_compressed_size = args.total_compressed_size;
            }
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[total_compressed_size] is unset!");
        }
        if (args != null && args.key_value_metadata != null) {
            this.key_value_metadata = args.key_value_metadata;
        }
        if (args != null && args.data_page_offset != null) {
            if (typeof args.data_page_offset === "number") {
                this.data_page_offset = new thrift.Int64(args.data_page_offset);
            }
            else {
                this.data_page_offset = args.data_page_offset;
            }
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[data_page_offset] is unset!");
        }
        if (args != null && args.index_page_offset != null) {
            if (typeof args.index_page_offset === "number") {
                this.index_page_offset = new thrift.Int64(args.index_page_offset);
            }
            else {
                this.index_page_offset = args.index_page_offset;
            }
        }
        if (args != null && args.dictionary_page_offset != null) {
            if (typeof args.dictionary_page_offset === "number") {
                this.dictionary_page_offset = new thrift.Int64(args.dictionary_page_offset);
            }
            else {
                this.dictionary_page_offset = args.dictionary_page_offset;
            }
        }
        if (args != null && args.statistics != null) {
            this.statistics = args.statistics;
        }
        if (args != null && args.encoding_stats != null) {
            this.encoding_stats = args.encoding_stats;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ColumnMetaData");
        if (this.type != null) {
            output.writeFieldBegin("type", thrift.Thrift.Type.I32, 1);
            output.writeI32(this.type);
            output.writeFieldEnd();
        }
        if (this.encodings != null) {
            output.writeFieldBegin("encodings", thrift.Thrift.Type.LIST, 2);
            output.writeListBegin(thrift.Thrift.Type.I32, this.encodings.length);
            this.encodings.forEach((value_57: Encoding): void => {
                output.writeI32(value_57);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.path_in_schema != null) {
            output.writeFieldBegin("path_in_schema", thrift.Thrift.Type.LIST, 3);
            output.writeListBegin(thrift.Thrift.Type.STRING, this.path_in_schema.length);
            this.path_in_schema.forEach((value_58: string): void => {
                output.writeString(value_58);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.codec != null) {
            output.writeFieldBegin("codec", thrift.Thrift.Type.I32, 4);
            output.writeI32(this.codec);
            output.writeFieldEnd();
        }
        if (this.num_values != null) {
            output.writeFieldBegin("num_values", thrift.Thrift.Type.I64, 5);
            output.writeI64(this.num_values);
            output.writeFieldEnd();
        }
        if (this.total_uncompressed_size != null) {
            output.writeFieldBegin("total_uncompressed_size", thrift.Thrift.Type.I64, 6);
            output.writeI64(this.total_uncompressed_size);
            output.writeFieldEnd();
        }
        if (this.total_compressed_size != null) {
            output.writeFieldBegin("total_compressed_size", thrift.Thrift.Type.I64, 7);
            output.writeI64(this.total_compressed_size);
            output.writeFieldEnd();
        }
        if (this.key_value_metadata != null) {
            output.writeFieldBegin("key_value_metadata", thrift.Thrift.Type.LIST, 8);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.key_value_metadata.length);
            this.key_value_metadata.forEach((value_59: KeyValue): void => {
                value_59.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.data_page_offset != null) {
            output.writeFieldBegin("data_page_offset", thrift.Thrift.Type.I64, 9);
            output.writeI64(this.data_page_offset);
            output.writeFieldEnd();
        }
        if (this.index_page_offset != null) {
            output.writeFieldBegin("index_page_offset", thrift.Thrift.Type.I64, 10);
            output.writeI64(this.index_page_offset);
            output.writeFieldEnd();
        }
        if (this.dictionary_page_offset != null) {
            output.writeFieldBegin("dictionary_page_offset", thrift.Thrift.Type.I64, 11);
            output.writeI64(this.dictionary_page_offset);
            output.writeFieldEnd();
        }
        if (this.statistics != null) {
            output.writeFieldBegin("statistics", thrift.Thrift.Type.STRUCT, 12);
            this.statistics.write(output);
            output.writeFieldEnd();
        }
        if (this.encoding_stats != null) {
            output.writeFieldBegin("encoding_stats", thrift.Thrift.Type.LIST, 13);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.encoding_stats.length);
            this.encoding_stats.forEach((value_60: PageEncodingStats): void => {
                value_60.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ColumnMetaData {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_61: Type = input.readI32();
                        _args.type = value_61;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_62: Array<Encoding> = new Array<Encoding>();
                        const metadata_1: thrift.TList = input.readListBegin();
                        const size_1: number = metadata_1.size;
                        for (let i_1: number = 0; i_1 < size_1; i_1++) {
                            const value_63: Encoding = input.readI32();
                            value_62.push(value_63);
                        }
                        input.readListEnd();
                        _args.encodings = value_62;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_64: Array<string> = new Array<string>();
                        const metadata_2: thrift.TList = input.readListBegin();
                        const size_2: number = metadata_2.size;
                        for (let i_2: number = 0; i_2 < size_2; i_2++) {
                            const value_65: string = input.readString();
                            value_64.push(value_65);
                        }
                        input.readListEnd();
                        _args.path_in_schema = value_64;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_66: CompressionCodec = input.readI32();
                        _args.codec = value_66;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.I64) {
                        const value_67: thrift.Int64 = input.readI64();
                        _args.num_values = value_67;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 6:
                    if (fieldType === thrift.Thrift.Type.I64) {
                        const value_68: thrift.Int64 = input.readI64();
                        _args.total_uncompressed_size = value_68;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 7:
                    if (fieldType === thrift.Thrift.Type.I64) {
                        const value_69: thrift.Int64 = input.readI64();
                        _args.total_compressed_size = value_69;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 8:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_70: Array<KeyValue> = new Array<KeyValue>();
                        const metadata_3: thrift.TList = input.readListBegin();
                        const size_3: number = metadata_3.size;
                        for (let i_3: number = 0; i_3 < size_3; i_3++) {
                            const value_71: KeyValue = KeyValue.read(input);
                            value_70.push(value_71);
                        }
                        input.readListEnd();
                        _args.key_value_metadata = value_70;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 9:
                    if (fieldType === thrift.Thrift.Type.I64) {
                        const value_72: thrift.Int64 = input.readI64();
                        _args.data_page_offset = value_72;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 10:
                    if (fieldType === thrift.Thrift.Type.I64) {
                        const value_73: thrift.Int64 = input.readI64();
                        _args.index_page_offset = value_73;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 11:
                    if (fieldType === thrift.Thrift.Type.I64) {
                        const value_74: thrift.Int64 = input.readI64();
                        _args.dictionary_page_offset = value_74;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 12:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_75: Statistics = Statistics.read(input);
                        _args.statistics = value_75;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 13:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_76: Array<PageEncodingStats> = new Array<PageEncodingStats>();
                        const metadata_4: thrift.TList = input.readListBegin();
                        const size_4: number = metadata_4.size;
                        for (let i_4: number = 0; i_4 < size_4; i_4++) {
                            const value_77: PageEncodingStats = PageEncodingStats.read(input);
                            value_76.push(value_77);
                        }
                        input.readListEnd();
                        _args.encoding_stats = value_76;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.type !== undefined && _args.encodings !== undefined && _args.path_in_schema !== undefined && _args.codec !== undefined && _args.num_values !== undefined && _args.total_uncompressed_size !== undefined && _args.total_compressed_size !== undefined && _args.data_page_offset !== undefined) {
            return new ColumnMetaData(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ColumnMetaData from input");
        }
    }
}
export interface IColumnChunkArgs {
    file_path?: string;
    file_offset: number | thrift.Int64;
    meta_data?: ColumnMetaData;
    offset_index_offset?: number | thrift.Int64;
    offset_index_length?: number;
    column_index_offset?: number | thrift.Int64;
    column_index_length?: number;
}
export class ColumnChunk {
    public file_path?: string;
    public file_offset: thrift.Int64;
    public meta_data?: ColumnMetaData;
    public offset_index_offset?: thrift.Int64;
    public offset_index_length?: number;
    public column_index_offset?: thrift.Int64;
    public column_index_length?: number;
    constructor(args: IColumnChunkArgs) {
        if (args != null && args.file_path != null) {
            this.file_path = args.file_path;
        }
        if (args != null && args.file_offset != null) {
            if (typeof args.file_offset === "number") {
                this.file_offset = new thrift.Int64(args.file_offset);
            }
            else {
                this.file_offset = args.file_offset;
            }
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[file_offset] is unset!");
        }
        if (args != null && args.meta_data != null) {
            this.meta_data = args.meta_data;
        }
        if (args != null && args.offset_index_offset != null) {
            if (typeof args.offset_index_offset === "number") {
                this.offset_index_offset = new thrift.Int64(args.offset_index_offset);
            }
            else {
                this.offset_index_offset = args.offset_index_offset;
            }
        }
        if (args != null && args.offset_index_length != null) {
            this.offset_index_length = args.offset_index_length;
        }
        if (args != null && args.column_index_offset != null) {
            if (typeof args.column_index_offset === "number") {
                this.column_index_offset = new thrift.Int64(args.column_index_offset);
            }
            else {
                this.column_index_offset = args.column_index_offset;
            }
        }
        if (args != null && args.column_index_length != null) {
            this.column_index_length = args.column_index_length;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ColumnChunk");
        if (this.file_path != null) {
            output.writeFieldBegin("file_path", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.file_path);
            output.writeFieldEnd();
        }
        if (this.file_offset != null) {
            output.writeFieldBegin("file_offset", thrift.Thrift.Type.I64, 2);
            output.writeI64(this.file_offset);
            output.writeFieldEnd();
        }
        if (this.meta_data != null) {
            output.writeFieldBegin("meta_data", thrift.Thrift.Type.STRUCT, 3);
            this.meta_data.write(output);
            output.writeFieldEnd();
        }
        if (this.offset_index_offset != null) {
            output.writeFieldBegin("offset_index_offset", thrift.Thrift.Type.I64, 4);
            output.writeI64(this.offset_index_offset);
            output.writeFieldEnd();
        }
        if (this.offset_index_length != null) {
            output.writeFieldBegin("offset_index_length", thrift.Thrift.Type.I32, 5);
            output.writeI32(this.offset_index_length);
            output.writeFieldEnd();
        }
        if (this.column_index_offset != null) {
            output.writeFieldBegin("column_index_offset", thrift.Thrift.Type.I64, 6);
            output.writeI64(this.column_index_offset);
            output.writeFieldEnd();
        }
        if (this.column_index_length != null) {
            output.writeFieldBegin("column_index_length", thrift.Thrift.Type.I32, 7);
            output.writeI32(this.column_index_length);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ColumnChunk {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_78: string = input.readString();
                        _args.file_path = value_78;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.I64) {
                        const value_79: thrift.Int64 = input.readI64();
                        _args.file_offset = value_79;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_80: ColumnMetaData = ColumnMetaData.read(input);
                        _args.meta_data = value_80;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.I64) {
                        const value_81: thrift.Int64 = input.readI64();
                        _args.offset_index_offset = value_81;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_82: number = input.readI32();
                        _args.offset_index_length = value_82;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 6:
                    if (fieldType === thrift.Thrift.Type.I64) {
                        const value_83: thrift.Int64 = input.readI64();
                        _args.column_index_offset = value_83;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 7:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_84: number = input.readI32();
                        _args.column_index_length = value_84;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.file_offset !== undefined) {
            return new ColumnChunk(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ColumnChunk from input");
        }
    }
}
export interface IRowGroupArgs {
    columns: Array<ColumnChunk>;
    total_byte_size: number | thrift.Int64;
    num_rows: number | thrift.Int64;
    sorting_columns?: Array<SortingColumn>;
}
export class RowGroup {
    public columns: Array<ColumnChunk>;
    public total_byte_size: thrift.Int64;
    public num_rows: thrift.Int64;
    public sorting_columns?: Array<SortingColumn>;
    constructor(args: IRowGroupArgs) {
        if (args != null && args.columns != null) {
            this.columns = args.columns;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[columns] is unset!");
        }
        if (args != null && args.total_byte_size != null) {
            if (typeof args.total_byte_size === "number") {
                this.total_byte_size = new thrift.Int64(args.total_byte_size);
            }
            else {
                this.total_byte_size = args.total_byte_size;
            }
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[total_byte_size] is unset!");
        }
        if (args != null && args.num_rows != null) {
            if (typeof args.num_rows === "number") {
                this.num_rows = new thrift.Int64(args.num_rows);
            }
            else {
                this.num_rows = args.num_rows;
            }
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[num_rows] is unset!");
        }
        if (args != null && args.sorting_columns != null) {
            this.sorting_columns = args.sorting_columns;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RowGroup");
        if (this.columns != null) {
            output.writeFieldBegin("columns", thrift.Thrift.Type.LIST, 1);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.columns.length);
            this.columns.forEach((value_85: ColumnChunk): void => {
                value_85.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.total_byte_size != null) {
            output.writeFieldBegin("total_byte_size", thrift.Thrift.Type.I64, 2);
            output.writeI64(this.total_byte_size);
            output.writeFieldEnd();
        }
        if (this.num_rows != null) {
            output.writeFieldBegin("num_rows", thrift.Thrift.Type.I64, 3);
            output.writeI64(this.num_rows);
            output.writeFieldEnd();
        }
        if (this.sorting_columns != null) {
            output.writeFieldBegin("sorting_columns", thrift.Thrift.Type.LIST, 4);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.sorting_columns.length);
            this.sorting_columns.forEach((value_86: SortingColumn): void => {
                value_86.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RowGroup {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_87: Array<ColumnChunk> = new Array<ColumnChunk>();
                        const metadata_5: thrift.TList = input.readListBegin();
                        const size_5: number = metadata_5.size;
                        for (let i_5: number = 0; i_5 < size_5; i_5++) {
                            const value_88: ColumnChunk = ColumnChunk.read(input);
                            value_87.push(value_88);
                        }
                        input.readListEnd();
                        _args.columns = value_87;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.I64) {
                        const value_89: thrift.Int64 = input.readI64();
                        _args.total_byte_size = value_89;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.I64) {
                        const value_90: thrift.Int64 = input.readI64();
                        _args.num_rows = value_90;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_91: Array<SortingColumn> = new Array<SortingColumn>();
                        const metadata_6: thrift.TList = input.readListBegin();
                        const size_6: number = metadata_6.size;
                        for (let i_6: number = 0; i_6 < size_6; i_6++) {
                            const value_92: SortingColumn = SortingColumn.read(input);
                            value_91.push(value_92);
                        }
                        input.readListEnd();
                        _args.sorting_columns = value_91;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.columns !== undefined && _args.total_byte_size !== undefined && _args.num_rows !== undefined) {
            return new RowGroup(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read RowGroup from input");
        }
    }
}
export interface ITypeDefinedOrderArgs {
}
export class TypeDefinedOrder {
    constructor() {
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("TypeDefinedOrder");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): TypeDefinedOrder {
        input.readStructBegin();
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new TypeDefinedOrder();
    }
}
export interface IPageLocationArgs {
    offset: number | thrift.Int64;
    compressed_page_size: number;
    first_row_index: number | thrift.Int64;
}
export class PageLocation {
    public offset: thrift.Int64;
    public compressed_page_size: number;
    public first_row_index: thrift.Int64;
    constructor(args: IPageLocationArgs) {
        if (args != null && args.offset != null) {
            if (typeof args.offset === "number") {
                this.offset = new thrift.Int64(args.offset);
            }
            else {
                this.offset = args.offset;
            }
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[offset] is unset!");
        }
        if (args != null && args.compressed_page_size != null) {
            this.compressed_page_size = args.compressed_page_size;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[compressed_page_size] is unset!");
        }
        if (args != null && args.first_row_index != null) {
            if (typeof args.first_row_index === "number") {
                this.first_row_index = new thrift.Int64(args.first_row_index);
            }
            else {
                this.first_row_index = args.first_row_index;
            }
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[first_row_index] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("PageLocation");
        if (this.offset != null) {
            output.writeFieldBegin("offset", thrift.Thrift.Type.I64, 1);
            output.writeI64(this.offset);
            output.writeFieldEnd();
        }
        if (this.compressed_page_size != null) {
            output.writeFieldBegin("compressed_page_size", thrift.Thrift.Type.I32, 2);
            output.writeI32(this.compressed_page_size);
            output.writeFieldEnd();
        }
        if (this.first_row_index != null) {
            output.writeFieldBegin("first_row_index", thrift.Thrift.Type.I64, 3);
            output.writeI64(this.first_row_index);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): PageLocation {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.I64) {
                        const value_93: thrift.Int64 = input.readI64();
                        _args.offset = value_93;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_94: number = input.readI32();
                        _args.compressed_page_size = value_94;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.I64) {
                        const value_95: thrift.Int64 = input.readI64();
                        _args.first_row_index = value_95;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.offset !== undefined && _args.compressed_page_size !== undefined && _args.first_row_index !== undefined) {
            return new PageLocation(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read PageLocation from input");
        }
    }
}
export interface IOffsetIndexArgs {
    page_locations: Array<PageLocation>;
}
export class OffsetIndex {
    public page_locations: Array<PageLocation>;
    constructor(args: IOffsetIndexArgs) {
        if (args != null && args.page_locations != null) {
            this.page_locations = args.page_locations;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[page_locations] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("OffsetIndex");
        if (this.page_locations != null) {
            output.writeFieldBegin("page_locations", thrift.Thrift.Type.LIST, 1);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.page_locations.length);
            this.page_locations.forEach((value_96: PageLocation): void => {
                value_96.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): OffsetIndex {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_97: Array<PageLocation> = new Array<PageLocation>();
                        const metadata_7: thrift.TList = input.readListBegin();
                        const size_7: number = metadata_7.size;
                        for (let i_7: number = 0; i_7 < size_7; i_7++) {
                            const value_98: PageLocation = PageLocation.read(input);
                            value_97.push(value_98);
                        }
                        input.readListEnd();
                        _args.page_locations = value_97;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.page_locations !== undefined) {
            return new OffsetIndex(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read OffsetIndex from input");
        }
    }
}
export interface IColumnIndexArgs {
    null_pages: Array<boolean>;
    min_values: Array<Buffer>;
    max_values: Array<Buffer>;
    boundary_order: BoundaryOrder;
    null_counts?: Array<thrift.Int64>;
}
export class ColumnIndex {
    public null_pages: Array<boolean>;
    public min_values: Array<Buffer>;
    public max_values: Array<Buffer>;
    public boundary_order: BoundaryOrder;
    public null_counts?: Array<thrift.Int64>;
    constructor(args: IColumnIndexArgs) {
        if (args != null && args.null_pages != null) {
            this.null_pages = args.null_pages;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[null_pages] is unset!");
        }
        if (args != null && args.min_values != null) {
            this.min_values = args.min_values;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[min_values] is unset!");
        }
        if (args != null && args.max_values != null) {
            this.max_values = args.max_values;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[max_values] is unset!");
        }
        if (args != null && args.boundary_order != null) {
            this.boundary_order = args.boundary_order;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[boundary_order] is unset!");
        }
        if (args != null && args.null_counts != null) {
            this.null_counts = args.null_counts;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ColumnIndex");
        if (this.null_pages != null) {
            output.writeFieldBegin("null_pages", thrift.Thrift.Type.LIST, 1);
            output.writeListBegin(thrift.Thrift.Type.BOOL, this.null_pages.length);
            this.null_pages.forEach((value_99: boolean): void => {
                output.writeBool(value_99);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.min_values != null) {
            output.writeFieldBegin("min_values", thrift.Thrift.Type.LIST, 2);
            output.writeListBegin(thrift.Thrift.Type.STRING, this.min_values.length);
            this.min_values.forEach((value_100: Buffer): void => {
                output.writeBinary(value_100);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.max_values != null) {
            output.writeFieldBegin("max_values", thrift.Thrift.Type.LIST, 3);
            output.writeListBegin(thrift.Thrift.Type.STRING, this.max_values.length);
            this.max_values.forEach((value_101: Buffer): void => {
                output.writeBinary(value_101);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.boundary_order != null) {
            output.writeFieldBegin("boundary_order", thrift.Thrift.Type.I32, 4);
            output.writeI32(this.boundary_order);
            output.writeFieldEnd();
        }
        if (this.null_counts != null) {
            output.writeFieldBegin("null_counts", thrift.Thrift.Type.LIST, 5);
            output.writeListBegin(thrift.Thrift.Type.I64, this.null_counts.length);
            this.null_counts.forEach((value_102: thrift.Int64): void => {
                output.writeI64(value_102);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ColumnIndex {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_103: Array<boolean> = new Array<boolean>();
                        const metadata_8: thrift.TList = input.readListBegin();
                        const size_8: number = metadata_8.size;
                        for (let i_8: number = 0; i_8 < size_8; i_8++) {
                            const value_104: boolean = input.readBool();
                            value_103.push(value_104);
                        }
                        input.readListEnd();
                        _args.null_pages = value_103;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_105: Array<Buffer> = new Array<Buffer>();
                        const metadata_9: thrift.TList = input.readListBegin();
                        const size_9: number = metadata_9.size;
                        for (let i_9: number = 0; i_9 < size_9; i_9++) {
                            const value_106: Buffer = input.readBinary();
                            value_105.push(value_106);
                        }
                        input.readListEnd();
                        _args.min_values = value_105;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_107: Array<Buffer> = new Array<Buffer>();
                        const metadata_10: thrift.TList = input.readListBegin();
                        const size_10: number = metadata_10.size;
                        for (let i_10: number = 0; i_10 < size_10; i_10++) {
                            const value_108: Buffer = input.readBinary();
                            value_107.push(value_108);
                        }
                        input.readListEnd();
                        _args.max_values = value_107;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_109: BoundaryOrder = input.readI32();
                        _args.boundary_order = value_109;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_110: Array<thrift.Int64> = new Array<thrift.Int64>();
                        const metadata_11: thrift.TList = input.readListBegin();
                        const size_11: number = metadata_11.size;
                        for (let i_11: number = 0; i_11 < size_11; i_11++) {
                            const value_111: thrift.Int64 = input.readI64();
                            value_110.push(value_111);
                        }
                        input.readListEnd();
                        _args.null_counts = value_110;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.null_pages !== undefined && _args.min_values !== undefined && _args.max_values !== undefined && _args.boundary_order !== undefined) {
            return new ColumnIndex(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ColumnIndex from input");
        }
    }
}
export interface IFileMetaDataArgs {
    version: number;
    schema: Array<SchemaElement>;
    num_rows: number | thrift.Int64;
    row_groups: Array<RowGroup>;
    key_value_metadata?: Array<KeyValue>;
    created_by?: string;
    column_orders?: Array<ColumnOrder>;
}
export class FileMetaData {
    public version: number;
    public schema: Array<SchemaElement>;
    public num_rows: thrift.Int64;
    public row_groups: Array<RowGroup>;
    public key_value_metadata?: Array<KeyValue>;
    public created_by?: string;
    public column_orders?: Array<ColumnOrder>;
    constructor(args: IFileMetaDataArgs) {
        if (args != null && args.version != null) {
            this.version = args.version;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[version] is unset!");
        }
        if (args != null && args.schema != null) {
            this.schema = args.schema;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[schema] is unset!");
        }
        if (args != null && args.num_rows != null) {
            if (typeof args.num_rows === "number") {
                this.num_rows = new thrift.Int64(args.num_rows);
            }
            else {
                this.num_rows = args.num_rows;
            }
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[num_rows] is unset!");
        }
        if (args != null && args.row_groups != null) {
            this.row_groups = args.row_groups;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[row_groups] is unset!");
        }
        if (args != null && args.key_value_metadata != null) {
            this.key_value_metadata = args.key_value_metadata;
        }
        if (args != null && args.created_by != null) {
            this.created_by = args.created_by;
        }
        if (args != null && args.column_orders != null) {
            this.column_orders = args.column_orders;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("FileMetaData");
        if (this.version != null) {
            output.writeFieldBegin("version", thrift.Thrift.Type.I32, 1);
            output.writeI32(this.version);
            output.writeFieldEnd();
        }
        if (this.schema != null) {
            output.writeFieldBegin("schema", thrift.Thrift.Type.LIST, 2);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.schema.length);
            this.schema.forEach((value_112: SchemaElement): void => {
                value_112.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.num_rows != null) {
            output.writeFieldBegin("num_rows", thrift.Thrift.Type.I64, 3);
            output.writeI64(this.num_rows);
            output.writeFieldEnd();
        }
        if (this.row_groups != null) {
            output.writeFieldBegin("row_groups", thrift.Thrift.Type.LIST, 4);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.row_groups.length);
            this.row_groups.forEach((value_113: RowGroup): void => {
                value_113.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.key_value_metadata != null) {
            output.writeFieldBegin("key_value_metadata", thrift.Thrift.Type.LIST, 5);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.key_value_metadata.length);
            this.key_value_metadata.forEach((value_114: KeyValue): void => {
                value_114.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.created_by != null) {
            output.writeFieldBegin("created_by", thrift.Thrift.Type.STRING, 6);
            output.writeString(this.created_by);
            output.writeFieldEnd();
        }
        if (this.column_orders != null) {
            output.writeFieldBegin("column_orders", thrift.Thrift.Type.LIST, 7);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.column_orders.length);
            this.column_orders.forEach((value_115: ColumnOrder): void => {
                value_115.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): FileMetaData {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_116: number = input.readI32();
                        _args.version = value_116;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_117: Array<SchemaElement> = new Array<SchemaElement>();
                        const metadata_12: thrift.TList = input.readListBegin();
                        const size_12: number = metadata_12.size;
                        for (let i_12: number = 0; i_12 < size_12; i_12++) {
                            const value_118: SchemaElement = SchemaElement.read(input);
                            value_117.push(value_118);
                        }
                        input.readListEnd();
                        _args.schema = value_117;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.I64) {
                        const value_119: thrift.Int64 = input.readI64();
                        _args.num_rows = value_119;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_120: Array<RowGroup> = new Array<RowGroup>();
                        const metadata_13: thrift.TList = input.readListBegin();
                        const size_13: number = metadata_13.size;
                        for (let i_13: number = 0; i_13 < size_13; i_13++) {
                            const value_121: RowGroup = RowGroup.read(input);
                            value_120.push(value_121);
                        }
                        input.readListEnd();
                        _args.row_groups = value_120;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_122: Array<KeyValue> = new Array<KeyValue>();
                        const metadata_14: thrift.TList = input.readListBegin();
                        const size_14: number = metadata_14.size;
                        for (let i_14: number = 0; i_14 < size_14; i_14++) {
                            const value_123: KeyValue = KeyValue.read(input);
                            value_122.push(value_123);
                        }
                        input.readListEnd();
                        _args.key_value_metadata = value_122;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 6:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_124: string = input.readString();
                        _args.created_by = value_124;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 7:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_125: Array<ColumnOrder> = new Array<ColumnOrder>();
                        const metadata_15: thrift.TList = input.readListBegin();
                        const size_15: number = metadata_15.size;
                        for (let i_15: number = 0; i_15 < size_15; i_15++) {
                            const value_126: ColumnOrder = ColumnOrder.read(input);
                            value_125.push(value_126);
                        }
                        input.readListEnd();
                        _args.column_orders = value_125;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.version !== undefined && _args.schema !== undefined && _args.num_rows !== undefined && _args.row_groups !== undefined) {
            return new FileMetaData(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read FileMetaData from input");
        }
    }
}
export interface ITimeUnitArgs {
    MILLIS?: MilliSeconds;
    MICROS?: MicroSeconds;
}
export class TimeUnit {
    public MILLIS?: MilliSeconds;
    public MICROS?: MicroSeconds;
    constructor(args?: ITimeUnitArgs) {
        let _fieldsSet: number = 0;
        if (args != null) {
            if (args.MILLIS != null) {
                _fieldsSet++;
                this.MILLIS = args.MILLIS;
            }
            if (args.MICROS != null) {
                _fieldsSet++;
                this.MICROS = args.MICROS;
            }
            if (_fieldsSet > 1) {
                throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.INVALID_DATA, "Cannot read a TUnion with more than one set value!");
            }
            else if (_fieldsSet < 1) {
                throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.INVALID_DATA, "Cannot read a TUnion with no set value!");
            }
        }
    }
    public static fromMILLIS(MILLIS: MilliSeconds): TimeUnit {
        return new TimeUnit({ MILLIS });
    }
    public static fromMICROS(MICROS: MicroSeconds): TimeUnit {
        return new TimeUnit({ MICROS });
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("TimeUnit");
        if (this.MILLIS != null) {
            output.writeFieldBegin("MILLIS", thrift.Thrift.Type.STRUCT, 1);
            this.MILLIS.write(output);
            output.writeFieldEnd();
        }
        if (this.MICROS != null) {
            output.writeFieldBegin("MICROS", thrift.Thrift.Type.STRUCT, 2);
            this.MICROS.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): TimeUnit {
        let _fieldsSet: number = 0;
        let _returnValue: TimeUnit | null = null;
        input.readStructBegin();
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        _fieldsSet++;
                        const value_127: MilliSeconds = MilliSeconds.read(input);
                        _returnValue = TimeUnit.fromMILLIS(value_127);
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        _fieldsSet++;
                        const value_128: MicroSeconds = MicroSeconds.read(input);
                        _returnValue = TimeUnit.fromMICROS(value_128);
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_fieldsSet > 1) {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.INVALID_DATA, "Cannot read a TUnion with more than one set value!");
        }
        else if (_fieldsSet < 1) {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.INVALID_DATA, "Cannot read a TUnion with no set value!");
        }
        if (_returnValue !== null) {
            return _returnValue;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read data for TUnion");
        }
    }
}
export interface ILogicalTypeArgs {
    STRING?: StringType;
    MAP?: MapType;
    LIST?: ListType;
    ENUM?: EnumType;
    DECIMAL?: DecimalType;
    DATE?: DateType;
    TIME?: TimeType;
    TIMESTAMP?: TimestampType;
    INTEGER?: IntType;
    UNKNOWN?: NullType;
    JSON?: JsonType;
    BSON?: BsonType;
    UUID?: UUIDType;
}
export class LogicalType {
    public STRING?: StringType;
    public MAP?: MapType;
    public LIST?: ListType;
    public ENUM?: EnumType;
    public DECIMAL?: DecimalType;
    public DATE?: DateType;
    public TIME?: TimeType;
    public TIMESTAMP?: TimestampType;
    public INTEGER?: IntType;
    public UNKNOWN?: NullType;
    public JSON?: JsonType;
    public BSON?: BsonType;
    public UUID?: UUIDType;
    constructor(args?: ILogicalTypeArgs) {
        let _fieldsSet: number = 0;
        if (args != null) {
            if (args.STRING != null) {
                _fieldsSet++;
                this.STRING = args.STRING;
            }
            if (args.MAP != null) {
                _fieldsSet++;
                this.MAP = args.MAP;
            }
            if (args.LIST != null) {
                _fieldsSet++;
                this.LIST = args.LIST;
            }
            if (args.ENUM != null) {
                _fieldsSet++;
                this.ENUM = args.ENUM;
            }
            if (args.DECIMAL != null) {
                _fieldsSet++;
                this.DECIMAL = args.DECIMAL;
            }
            if (args.DATE != null) {
                _fieldsSet++;
                this.DATE = args.DATE;
            }
            if (args.TIME != null) {
                _fieldsSet++;
                this.TIME = args.TIME;
            }
            if (args.TIMESTAMP != null) {
                _fieldsSet++;
                this.TIMESTAMP = args.TIMESTAMP;
            }
            if (args.INTEGER != null) {
                _fieldsSet++;
                this.INTEGER = args.INTEGER;
            }
            if (args.UNKNOWN != null) {
                _fieldsSet++;
                this.UNKNOWN = args.UNKNOWN;
            }
            if (args.JSON != null) {
                _fieldsSet++;
                this.JSON = args.JSON;
            }
            if (args.BSON != null) {
                _fieldsSet++;
                this.BSON = args.BSON;
            }
            if (args.UUID != null) {
                _fieldsSet++;
                this.UUID = args.UUID;
            }
            if (_fieldsSet > 1) {
                throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.INVALID_DATA, "Cannot read a TUnion with more than one set value!");
            }
            else if (_fieldsSet < 1) {
                throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.INVALID_DATA, "Cannot read a TUnion with no set value!");
            }
        }
    }
    public static fromSTRING(STRING: StringType): LogicalType {
        return new LogicalType({ STRING });
    }
    public static fromMAP(MAP: MapType): LogicalType {
        return new LogicalType({ MAP });
    }
    public static fromLIST(LIST: ListType): LogicalType {
        return new LogicalType({ LIST });
    }
    public static fromENUM(ENUM: EnumType): LogicalType {
        return new LogicalType({ ENUM });
    }
    public static fromDECIMAL(DECIMAL: DecimalType): LogicalType {
        return new LogicalType({ DECIMAL });
    }
    public static fromDATE(DATE: DateType): LogicalType {
        return new LogicalType({ DATE });
    }
    public static fromTIME(TIME: TimeType): LogicalType {
        return new LogicalType({ TIME });
    }
    public static fromTIMESTAMP(TIMESTAMP: TimestampType): LogicalType {
        return new LogicalType({ TIMESTAMP });
    }
    public static fromINTEGER(INTEGER: IntType): LogicalType {
        return new LogicalType({ INTEGER });
    }
    public static fromUNKNOWN(UNKNOWN: NullType): LogicalType {
        return new LogicalType({ UNKNOWN });
    }
    public static fromJSON(JSON: JsonType): LogicalType {
        return new LogicalType({ JSON });
    }
    public static fromBSON(BSON: BsonType): LogicalType {
        return new LogicalType({ BSON });
    }
    public static fromUUID(UUID: UUIDType): LogicalType {
        return new LogicalType({ UUID });
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("LogicalType");
        if (this.STRING != null) {
            output.writeFieldBegin("STRING", thrift.Thrift.Type.STRUCT, 1);
            this.STRING.write(output);
            output.writeFieldEnd();
        }
        if (this.MAP != null) {
            output.writeFieldBegin("MAP", thrift.Thrift.Type.STRUCT, 2);
            this.MAP.write(output);
            output.writeFieldEnd();
        }
        if (this.LIST != null) {
            output.writeFieldBegin("LIST", thrift.Thrift.Type.STRUCT, 3);
            this.LIST.write(output);
            output.writeFieldEnd();
        }
        if (this.ENUM != null) {
            output.writeFieldBegin("ENUM", thrift.Thrift.Type.STRUCT, 4);
            this.ENUM.write(output);
            output.writeFieldEnd();
        }
        if (this.DECIMAL != null) {
            output.writeFieldBegin("DECIMAL", thrift.Thrift.Type.STRUCT, 5);
            this.DECIMAL.write(output);
            output.writeFieldEnd();
        }
        if (this.DATE != null) {
            output.writeFieldBegin("DATE", thrift.Thrift.Type.STRUCT, 6);
            this.DATE.write(output);
            output.writeFieldEnd();
        }
        if (this.TIME != null) {
            output.writeFieldBegin("TIME", thrift.Thrift.Type.STRUCT, 7);
            this.TIME.write(output);
            output.writeFieldEnd();
        }
        if (this.TIMESTAMP != null) {
            output.writeFieldBegin("TIMESTAMP", thrift.Thrift.Type.STRUCT, 8);
            this.TIMESTAMP.write(output);
            output.writeFieldEnd();
        }
        if (this.INTEGER != null) {
            output.writeFieldBegin("INTEGER", thrift.Thrift.Type.STRUCT, 10);
            this.INTEGER.write(output);
            output.writeFieldEnd();
        }
        if (this.UNKNOWN != null) {
            output.writeFieldBegin("UNKNOWN", thrift.Thrift.Type.STRUCT, 11);
            this.UNKNOWN.write(output);
            output.writeFieldEnd();
        }
        if (this.JSON != null) {
            output.writeFieldBegin("JSON", thrift.Thrift.Type.STRUCT, 12);
            this.JSON.write(output);
            output.writeFieldEnd();
        }
        if (this.BSON != null) {
            output.writeFieldBegin("BSON", thrift.Thrift.Type.STRUCT, 13);
            this.BSON.write(output);
            output.writeFieldEnd();
        }
        if (this.UUID != null) {
            output.writeFieldBegin("UUID", thrift.Thrift.Type.STRUCT, 14);
            this.UUID.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): LogicalType {
        let _fieldsSet: number = 0;
        let _returnValue: LogicalType | null = null;
        input.readStructBegin();
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        _fieldsSet++;
                        const value_129: StringType = StringType.read(input);
                        _returnValue = LogicalType.fromSTRING(value_129);
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        _fieldsSet++;
                        const value_130: MapType = MapType.read(input);
                        _returnValue = LogicalType.fromMAP(value_130);
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        _fieldsSet++;
                        const value_131: ListType = ListType.read(input);
                        _returnValue = LogicalType.fromLIST(value_131);
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        _fieldsSet++;
                        const value_132: EnumType = EnumType.read(input);
                        _returnValue = LogicalType.fromENUM(value_132);
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        _fieldsSet++;
                        const value_133: DecimalType = DecimalType.read(input);
                        _returnValue = LogicalType.fromDECIMAL(value_133);
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 6:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        _fieldsSet++;
                        const value_134: DateType = DateType.read(input);
                        _returnValue = LogicalType.fromDATE(value_134);
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 7:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        _fieldsSet++;
                        const value_135: TimeType = TimeType.read(input);
                        _returnValue = LogicalType.fromTIME(value_135);
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 8:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        _fieldsSet++;
                        const value_136: TimestampType = TimestampType.read(input);
                        _returnValue = LogicalType.fromTIMESTAMP(value_136);
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 10:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        _fieldsSet++;
                        const value_137: IntType = IntType.read(input);
                        _returnValue = LogicalType.fromINTEGER(value_137);
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 11:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        _fieldsSet++;
                        const value_138: NullType = NullType.read(input);
                        _returnValue = LogicalType.fromUNKNOWN(value_138);
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 12:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        _fieldsSet++;
                        const value_139: JsonType = JsonType.read(input);
                        _returnValue = LogicalType.fromJSON(value_139);
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 13:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        _fieldsSet++;
                        const value_140: BsonType = BsonType.read(input);
                        _returnValue = LogicalType.fromBSON(value_140);
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 14:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        _fieldsSet++;
                        const value_141: UUIDType = UUIDType.read(input);
                        _returnValue = LogicalType.fromUUID(value_141);
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_fieldsSet > 1) {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.INVALID_DATA, "Cannot read a TUnion with more than one set value!");
        }
        else if (_fieldsSet < 1) {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.INVALID_DATA, "Cannot read a TUnion with no set value!");
        }
        if (_returnValue !== null) {
            return _returnValue;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read data for TUnion");
        }
    }
}
export interface IColumnOrderArgs {
    TYPE_ORDER?: TypeDefinedOrder;
}
export class ColumnOrder {
    public TYPE_ORDER?: TypeDefinedOrder;
    constructor(args?: IColumnOrderArgs) {
        let _fieldsSet: number = 0;
        if (args != null) {
            if (args.TYPE_ORDER != null) {
                _fieldsSet++;
                this.TYPE_ORDER = args.TYPE_ORDER;
            }
            if (_fieldsSet > 1) {
                throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.INVALID_DATA, "Cannot read a TUnion with more than one set value!");
            }
            else if (_fieldsSet < 1) {
                throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.INVALID_DATA, "Cannot read a TUnion with no set value!");
            }
        }
    }
    public static fromTYPE_ORDER(TYPE_ORDER: TypeDefinedOrder): ColumnOrder {
        return new ColumnOrder({ TYPE_ORDER });
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ColumnOrder");
        if (this.TYPE_ORDER != null) {
            output.writeFieldBegin("TYPE_ORDER", thrift.Thrift.Type.STRUCT, 1);
            this.TYPE_ORDER.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ColumnOrder {
        let _fieldsSet: number = 0;
        let _returnValue: ColumnOrder | null = null;
        input.readStructBegin();
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        _fieldsSet++;
                        const value_142: TypeDefinedOrder = TypeDefinedOrder.read(input);
                        _returnValue = ColumnOrder.fromTYPE_ORDER(value_142);
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_fieldsSet > 1) {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.INVALID_DATA, "Cannot read a TUnion with more than one set value!");
        }
        else if (_fieldsSet < 1) {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.INVALID_DATA, "Cannot read a TUnion with no set value!");
        }
        if (_returnValue !== null) {
            return _returnValue;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read data for TUnion");
        }
    }
}
